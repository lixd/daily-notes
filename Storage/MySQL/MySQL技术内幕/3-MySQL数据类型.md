# MySQL数据类型



# 1. 数据值类别

MySQL支持多种常规类别的数据值，包括数值、字符串、时间、日期这样的时态值空间值以及NULL值。

### 1. 数值

MySQL能识别的数值包括整数(无小数位)、定点数或浮点数以及位域值(bit-field value)

位域值可以写成`b'val'`或者`0bval`,val由一个或多个二进制数字构成。

例如:`b'1010`或者`0b1010`



### 2. 字符串

字符串尽量使用单引号。具体原因如下：

* 1.SQL语言标准规定使用单引号
* 2.如果启用了SQL模式`ANSI_QUOTES`,那么MySQL会将双引号处理成将标识符引起来的符号，而不会只把它当成字符串引起来的符号。

例子：

```mysql
SELECT "last_name" FROM president;
```

如果开启了`ANSI_QUOTES`模式，那么会从president表中取`last_name`列的值

如果没开则会为该表的每行选取一次字符串`last_name`

MySQL能识别出字符串里的转义符号(`\`)。

#### 1. 字符集

字符串一般可以分为二进制串和非二进制串。

二进制串是一组字节序列。

非二进制串是一个字符序列。每个非二进制串都与字符集有关。

字符集决定了：哪些字符串可以用；MySQL会如何解释字符串的内容。

### 3. 时态值

时态值包括日期值或时间值。

如`2012-06-17`或`12:30:43`

也可以合并在一起`2012-06-17 12:30:43`

MySQL是按`年-月-日`的顺序来表示日期的。

### 4. 空间值

MySQL支持`空间值`，可以让我们直接表示想点、线、多边形这样的值。

### 5. 布尔值

`布尔值`:任何非零非NULL的值都会被当做真，布尔常量TRUE和FLASE分别被当作1和0，不区分大小写。

### 6. NULL值

`NULL`值是一种没有类型的值。通常用来表示无值、未知值、缺失值、超界等。



## 2. MySQL数据类型

建表时必须为每一列指定数据类型,列的数据类型比值分类更具体，如`smallint`和`varchar(32)`。



### 1. 列的默认值

可以使用`DEFAULT def_value`子句为列指定默认值，其中默认值`def_value`必须是一个常量，不能为表达式也不能引用其他列。

如果没设置默认值：如果列可以为NULL则会设置为NULL；如果不能为NULL则根据是否启用SQL严格模式：

* 1.未启用则会设置为其数据类型的隐含默认值
* 2.启用后如果是事务表则会出现错误。若不是事务表则只会在insert第一行时报错，insert后续行则可以手动选择报错停止或者设置为隐含默认值。



### 3. 字符串数据类型

#### 1. CHAR和VARCHAR

`CHAR`和`VARCHAR`主要用于保存非二进制数据。

* CHAR是一种长度固定的类型，VARCHAR是一种长度可变的类型。
* 从CHAR检索出来的值，其尾部空格会被移除，对于CHAR(M)列如果存入时长度小于M则会用空格补齐到M，但是在检索时这些空格会被移除。
* 对于VARCHAR列，其尾部空格在存储和检索时都会保留。



CHAR最大长度M取值范围是0~255,如果省略M则默认是CHAR(1)。

> CHAR(0)也是允许的，如果CHAR(0)列可以为NULL那么取值只有NULL和空串两种，CHAR(0)只占用很少的空间(1个二进制位)可以用来表示`开/关`值。

VARCHAR最大长度M取值范围是0~65535，但是实际容量肯定是小于65535的，因为MySQL中行的最大长度是65535个字节，影响因素如下：

* 1.一个长VARCHAR列需要两个字节来存放字符串的长度
* 2.表里其他列也会占一部分空间
* 3.使用多字节字符会减少字符个数，最终长度不会超过最大长度。
* 4.MyISAM表处理固定长度行效率比可变长度高，如果各个值长度差别不大选用CHAR往往会比VARCHAR好。

**varchar长度问题**

- MySQL要求一个行的定义长度不能超过65535即64K
- 对于未指定varchar字段not null的表，会有1个字节专门表示该字段是否为null
- varchar(M)，当M范围为0<=M<=255时会专门有一个字节记录varchar型字符串长度，当M>255时会专门有两个字节记录varchar型字符串的长度，把这一点和上一点结合，那么65535个字节实际可用的为65535-3=65532个字节
- **所有英文无论其编码方式，都占用1个字节，但对于gbk编码，一个汉字占两个字节，因此最大M=65532/2=32766；对于utf8编码，一个汉字占3个字节，因此最大M=65532/3=21844，上面的结论都成立**
- 举一反三，对于utfmb4编码方式，1个字符最大可能占4个字节，那么varchar(M)，M最大为65532/4=16383，可以自己验证一下

#### 2. BINARY和VARBINARY

BINARY和VARBINARY与`CHAR`和`VARCHAR`类似。

* `CHAR`和`VARCHAR`主要用于存储字符的非二进制类型。
* `BINARY`和`VARBINARY`主要用于存储字节的二进制类型。

同样 BINARY(M)不足时会用0x00补齐，但是在检索时不会去掉。

VARBINARY则不会进行任何操作。



#### 3. BLOB和TEXT

> 一般不推荐使用这两个。

blob指的是二进制大对象(binary large object),实际上是一个可以存放任何内容的容器。

BLOB是个类型系列，共包括四种BLOB类型：TinyBlob、Blob、MediumBlob、LongBlob，这几个类型之间的唯一区别是在存储文件的最大尺寸不同。

TEXT与BLOB类似，但是TEXT是存储字符非二进制数据串，BLOB是存储字节的二进制串。

TEXT也是个类型系列，共包括四种TEXT类型：TINYTEXT, TEXT, MEDIUMTEXT,LONGTEXT。

| 字段类型              | 最大长度（字节） | 存储需求                          |
| --------------------- | ---------------- | --------------------------------- |
| TinyBlob/TINYTEXT     | 2^8-1            | 值的长度加上用于记录长度的1个字节 |
| Blob/TEXT             | 2^16-1           | 值的长度加上用于记录长度的2个字节 |
| MediumBlob/MEDIUMTEXT | 2^24-1           | 值的长度加上用于记录长度的3个字节 |
| LongBlob/LONGTEXT     | 2^32-1           | 值的长度加上用于记录长度的4个字节 |

#### 4. ENUM和SET数据类型

ENUM和SET是比较特殊的字符串类型，只能从事先定义好的字符串列表里取值。主要区别是：ENUM列值必须包含且只能包含`一个`值列表成员。SET列值允许包含`任意多个`(可以为空)。

ENUM类型定义的是枚举集合，它最多允许65535个成员。

> 比如性别可以用ENUM（'男'，'女')

SET类型最多允许有64个成员。

> 让用户从固定列表中进行多选时可以用SET。



ENUM和SET在创建是虽然都是字符串类型吗，但是它们的成员在内部存储形式是数字。

MySQL将从1开始对ENUM列定义里的成员进行顺序编号(0被保留为错误码)。

占用大小由枚举值个数决定。

>  1字节可以保存256个值，2字节能存65536个值。

SET与ENUM稍有不同，并未按顺序编号，每个SET成员对应SET值里的一个二进制位。

64个成员最多占8字节。



#### 5. 如何选择

**1.是要表示字符数据还是二进制数据？**

字符数据则选择非二进制串类型，二进制数据则选用二进制串类型。

**2.比较操作需要区分大小写吗？**
如果是则应该选用非二进制串类型，因为这些存储字符与字符集和排序规则是相关联的。如果不区分大小写则应该选一种二进制排序规则或区分大小写的排序规则。

> 二进制排序规则比较字符时使用的是他们的数值编码，区分大小写的排序规则则使用的是该排序规则特有的字符顺序，不一定与字符编码大小顺序相同。

**3.想要少占用存储空间吗？**

如果是则选择可变长度的类型

**4.列的值总是固定的几个吗？**

是的话ENUM或者SET可能是最好的选择。

**5.尾部填充很重要吗？**

如果必须原样存入则应该用TEXT和VACHAR存非二进制串，BLOB和VARBINARY存二进制串。

填充值处理方式如下表:

| 数据类型           | 存储     | 检索   |
| ------------------ | -------- | ------ |
| CHAR               | 填充空格 | 去掉   |
| BINARY             | 填充0x00 | 不处理 |
| VARCHAR，VARBINARY | 不处理   | 不处理 |
| TEXT，BLOB         | 不处理   | 不处理 |

### 4. 时态数据类型

MySQL提供了多种存储时态值的类型：DATE、TIME、DATETIME、TIMESTAMP

和YEAR。

如果需要声明包含小数秒部分的时态类型列，则需把定义写成type_name(fsp)。

type_name为类型，如：TIME，DATATIME或TIMESTAMP。

fsp为小数秒精度 取值范围0~6 默认为0

例如:TIME(3)则允许小数位数为3位。

#### 1. DATE、TIME和DATATIME

DATE、TIME分别用于保存日期值(`CCYY-MM-DD`)和时间值(`hh:mm:ss[.uuuuuu]`)，而DATATIME则保存日期和时间的组合值(`CCYY-MM-DD hh:mm:ss[.uuuuuu]`)

把DATE值赋值给DATATIME则会自动把TIME部分补足为`00:00:00`

相反DATATIME值赋值给DATA或TIME也会自动去掉不相干的部分。

#### 2. TIMESTAMP

TIMESTAMP是一种时态数据类型，用于存储日期和时间的组合值。

**DATATIME与TIMESTAMP差别？**

1）占用存储空间

| 类型      | 占用字节 | 表示形式            |
| :-------- | :------- | :------------------ |
| datetime  | 8 字节   | yyyy-mm-dd hh:mm:ss |
| timestamp | 4 字节   | yyyy-mm-dd hh:mm:ss |

2）表示范围

| 类型      | 表示范围                                                     |
| --------- | ------------------------------------------------------------ |
| datetime  | '1000-01-01 00:00:00.000000' to '9999-12-31 23:59:59.999999' |
| timestamp | '1970-01-01 00:00:01.000000' to '2038-01-19 03:14:07.999999' |

3）时区

timestamp将客户端插入的时间从当前时区转换为utc（世界标准时间）进行存储。查询时，又将其转换为客户端当前时区进行返回。

datetime不做任何改变，基本上是原样输入和输出。

4）其它区别

设置字段为null时，timestamp会自动存储当前时间，datetime 存储的仍然是null。


#### 3. YEAR

单字节数据类型，用于提高年值得表示效率。

声明时可以指定显示宽度(从最后一位开始显示)`YEAR(M)` M值只能是4或者2

如2019年在YEAR(4)显示为2019，在YEAR(2)则显示为19

如果是YEAR(2)只能显示1970到2069 因为1970和2070都会显示为70无法区分了。



#### 4. 自动特性

对于DATETIME和TIMESTAMP列可以用自动初始化和自动更新特效。

* 自动初始化意味着insert时未指定值那么会被设置为当前时间戳
* 自动更新则是对于已有行 更新其他任意列时这两种类型的列都会被更新为当前时间戳。

定义时的格式如下

```mysql
col_name TIMESTAMP [DEFAULT default_value] [ON UPDATE CURRENT_TIMESTAMP]
```

ON UPDATE CURRENT_TIMESTAMP则设置了自动更新特性。

DEFAULT default_value中把default_value设置为CURRENT_TIMESTAMP则开启自动初始化特性，没有指定默认值则会设置为0。

比如对于某个表需要指定数据的创建时间和最近的更新时间则可以这样设置

```mysql
create_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP，
update_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
```

insert时创建时间更新时间都设置为当前时间戳，后续更新时自动更新update_time。



## 3. MySQL如何处理无效值

默认情况下MySQL会安装以下规则处理越界值和其他非正常值。

* 1.对数值列和TIME列，超出合法取值范围的那些值会被截断到离取值范围最近的那个端点。假设范围是0~100 那么存入101则会截断到100然后存起来，即存入101，得到100。
* 2.对于除TIME列以外的时态类型，非法值会转换为类型的零值。
* 3.字符串则截取长度(ENUM和SET除外)
* 4.NUM和SET赋值时只能存定义时指定的那些值，其他非法值会被忽略。例如SET('A','B','C')，存入('C','D')那D就会被忽略掉最后只会存入C。



## 4. 处理序列

MySQL的AUTO_INCREMENT列属性会自动生成序列编号，具有如下特性：

* 1.每个表只能有一个列具有该属性并且应该为整数数据类型
* 2.该列必须建立索引,常见的是PRIMARY KEY或UNIQUE 当然也允许使用不唯一的索引。
* 3.该列必须拥有NOT NULL约束条件，就算没显式声明MySQL也会自动声明。
* 4.对该列插入0或NULL值会触发MySQL自动生成编号
* 5.可以调用LAST_INSEERT_ID()函数获得最近生成的序列号，批量插入时只会返回第一个生成的id。



如果对AUTO_INCREMENT列插入一个不是0也不是NULL的值会有两种情况:

* 1.如果该值存在则发生键重复错误
* 2.不存在则插入成功，如果该值比当前自动生成的序列要大就把自动生成序列更新为当前值。

> 例如当前AUTO_INCREMENT列已经生成了3个序列1，2，3了此时插入3肯定报错，键重复了，但是插入5的话是可以的，同时会把自动序列更新为5，下次插入NULL值或0值是自动生成的序列就是6了而不是4。

但是如果使用REPLACE来更新的话就不会重置自动生成序列。



建表时可以使用`AUTO_INCREMENT=n`修改序列初始值



### 1. 注意事项

* 1.AUTO_INCREMENT机制用途主要是生成一个正整数序列，因此可以把该列定义为UNSIGNED类型 这样可以增加序列编号的范围。
* 2.AUTO_INCREMENT会受到底层数据类型取值范围约束，比如TINYINT类型列的最大序列编号为127，超过后悔因为键重复而报错。
* 3.使用TRUNCATE TABLE清除表内容时会重置计数序列到1。



### 2. 实用技巧

1.表已经存在后添加AUTO_INCREMENT列会自动对已存在的行进行编号

2.想要对AUTO_INCREMENT列重新编号以消除因为删除行而导致的序号断裂最简单的方法是先把AUTO_INCREMENT列删掉然后在添加回去,因为1中提到了添加时会自动为已存在的行进行编号。

3.在没有AUTO_INCREMENT列的情况下生成序列

此时可以在插入或修改时使用`LAST_INSERT_ID(expr)`函数，下次在调用`LAST_INSERT_ID()`函数则会返回表达式expr的值。

主要用于创建一个只有一行的表，其中就包含了一个在每次需要该序列里下一个值时都会进行更新的值：例如

```mysql
CREATE TABLE sseq_table (
	seq INT UNSIGNED NOT NULL
);
INSERT INTO seq_table VALUES(0)
```

此时表中只有一个seq切值为0

```mysql
UPDATE seq_table SET seq=LAST_INSERT_ID(seq+1);
SELECT LAST_INSERT_ID();
```

update语句将检索seq列的当前值并把他加1从而产生序列的下一个编号。利用`LAST_INSERT_ID(seq+1)`生成的新编号值和AUTO_INCREMENT很像，因此可以通过调用不带参数的LAST_INSERT_ID()来检索它。

因为LAST_INSERT_ID()是客户端专用的，所以就算这期间其他客户端有生成了其他的编号也不会影响当前客户端。

利用这种方法可以生成任意步长的序列。

```mysql
#步长为1
UPDATE seq_table SET seq=LAST_INSERT_ID(seq+1);
#步长为10
UPDATE seq_table SET seq=LAST_INSERT_ID(seq+10);
#步长为-1
UPDATE seq_table SET seq=LAST_INSERT_ID(seq-1);
```

虽然只有事务或者锁也可以达到同样的目的，但是相比之下这个就很简单，没这么复杂。



## 5. 选择数据类型

MySQL中列的数据类型选择主要包括以下几个方面：

**1.列要存放什么类型的值？**

数字？字符串？还是日期？虽然可以把任何类型的值都用字符串来表示但是很明显现在合适的类型可能会获得更好的性能。

一般来说数字类型列存储数字，字符类型存储字符串，时态类型存储日期和时间。

**2.值是否都在某个特定区间内？**

如果是整数且总为非负数那么可以考虑选用`UNSIGNED` ；如果是字符串且来自某个固定且有限的集合可以考虑选择`ENUM`或者`SET`;数据类型占用空间和取值范围是相互影响的，尽量选择合适的类型，字符串则选择合适的长度。
**3.在性能和效率方面要考虑哪些问题？**
有些类型处理起来效率比其他类型更高。数字操作通常比字符串操作更快；短字符串比较比长字符串比较要快；对于MyISAM表固定长度的行性能比可变长度的行要好。


