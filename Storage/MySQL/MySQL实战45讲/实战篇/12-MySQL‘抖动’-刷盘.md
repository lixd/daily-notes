# MySQL 抖动

## 1. 概述

有时候查询性能会突然抖动一下，大部分时间都很快，突然有一下子会很慢。

主要是应为脏页刷盘，导致性能突然下降。



## 2. 脏页&干净页

InnoDB 在处理更新语句的时候,直接**更新内存数据并写入 redo log** 就向客户端返回更新成功了。

> 即 change buffer 机制，该机制主要用于提升性能。将随机写转换为顺序写。

**当内存数据页跟磁盘数据页内容不一致的时候，我们称这个内存页为`脏页`。内存数据写入到磁盘后，内存和磁盘上的数据页的内容就一致了，称为`干净页`。**

> 不论是脏页还是干净页，都在内存中的。



## 3. 脏页刷盘

你不难想象，平时执行很快的更新操作，其实就是在写内存和日志，而 MySQL 偶尔“抖”一下的那个瞬间，可能就是在刷脏页（flush）。



### 刷脏页时机

以下几种情况都会引发数据库的 flush 过程：

* 1）redo log文件写满
  * redo log 是循环写的，写满后只能停下其他工作先将脏页刷盘（刷盘后对应的 redo log 就不需要保留了，等于是腾出了空间），如果不刷盘，那么 redo log 被覆盖后可能会出现数据丢失。
* 2）内存不足
  * 当需要新的内存页，而内存不够用的时候，就要淘汰一些数据页，空出内存给别的数据页使用。如果淘汰的是“脏页”，就要先将脏页写到磁盘。
* 3）MySQL空闲
  * MySQL觉得系统空闲时也会执行脏页刷盘操作，反正闲着也是闲着
* 4）MySQL 正常关闭
  * MySQL 关闭时会把内存的脏页都 flush 到磁盘上，这样下次 MySQL 启动的时候，就可以直接从磁盘上读数据，启动速度会很快。

**InnoDB 用缓冲池（buffer pool）管理内存，缓冲池中的内存页有三种状态：**

* 第一种是，还没有使用的；
* 第二种是，使用了并且是干净页；
* 第三种是，使用了并且是脏页。

InnoDB 的策略是尽量使用内存，因此对于一个长时间运行的库来说，未被使用的页面很少。

而当要读入的数据页没有在内存的时候，就必须到缓冲池中申请一个数据页。这时候只能把最久不使用的数据页从内存中淘汰掉：如果要淘汰的是一个干净页，就直接释放出来复用；但如果是脏页呢，就必须将脏页先刷到磁盘，变成干净页后才能复用。



### 4种情况 flush 对性能的影响

* 情况一 redo log 写满：需要尽量避免。出现这种情况的时候，整个系统就不能再接受更新了，所有的更新都必须堵住。
  * 如果你从监控上看，这时候更新数会跌为 0。
* 情况二 内存不足：这种情况是常态，无需过多操作
* 情况三四 系统空闲或正常关闭，则不会影响性能
  * 系统空闲或者正常关闭的时候一般也不会关注性能

所以，刷脏页虽然是常态，但是出现以下这两种情况，都是会明显影响性能的：

* 1）一个查询要淘汰的脏页个数太多，会导致查询的响应时间明显变长；
* 2）日志写满，更新全部堵住，写性能跌为 0，这种情况对敏感业务来说，是不能接受的。



所以，InnoDB 需要有控制脏页比例的机制，来尽量避免上面的这两种情况。



## 4. 刷脏页策略

**innodb_io_capacity**

首先，你要正确地告诉 InnoDB 所在主机的 IO 能力，这样 InnoDB 才能知道需要全力刷脏页的时候，可以刷多快。

这就要用到 innodb_io_capacity 这个参数了，它会告诉 InnoDB 你的磁盘能力。这个值我建议你设置成磁盘的 IOPS。磁盘的 IOPS 可以通过 fio 这个工具来测试：

```sh
$ fio -filename=$filename -direct=1 -iodepth 1 -thread -rw=randrw -ioengine=psync -bs=16k -size=500M -numjobs=10 -runtime=10 -group_reporting -name=mytest 
```

**innodb_flush_neighbors**

在 InnoDB 中刷脏页也存在“连坐”机制。具体如下：

在准备刷一个脏页的时候，如果这个数据页旁边的数据页刚好是脏页，就会把这个“邻居”也带着一起刷掉；而且这个把“邻居”拖下水的逻辑还可以继续蔓延，也就是对于每个邻居数据页，如果跟它相邻的数据页也还是脏页的话，也会被放到一起刷。

innodb_flush_neighbors 参数就是用来控制这个行为的，值为 1 的时候会有上述的“连坐”机制，值为 0 时表示不找邻居，自己刷自己的。

这个优化在机械硬盘时代是很有意义的，可以减少很多随机 IO。而如果使用的是 SSD 这类 IOPS 比较高的设备的话，建议设置成 0。因为这时候 IOPS 往往不是瓶颈，而“只刷自己”，就能更快地执行完必要的刷脏页操作，减少 SQL 语句响应时间。

> 在 MySQL 8.0 中，innodb_flush_neighbors 参数的默认值已经是 0 了。





**刷脏页的相关因素**

如果脏页刷太慢，会出现什么情况？首先是内存脏页太多，其次是 redo log 写满。

所以，InnoDB 的刷盘速度就是要参考这两个因素：一个是脏页比例，一个是 redo log 写盘速度。

具体计算公式如下：

* 1）InnoDB 会根据当前的脏页比例（假设为 M），算出一个范围在 0 到 100 之间的数字，记为 F1(M)。
* 2）第二个数字则是当前写入的序号跟 checkpoint 对应的序号之间的差值，假设为 N，InnoDB 会根据这个 N 算出一个范围在 0 到 100 之间的数字，这个计算公式可以记为 F2(N)。
* 3）然后，**根据上述算得的 F1(M) 和 F2(N) 两个值，取其中较大的值记为 R，之后引擎就可以按照 innodb_io_capacity 定义的能力乘以 R% 来控制刷脏页的速度**。



其中 F1 计算的伪代码如下：

```c

F1(M)
{
  if M>=innodb_max_dirty_pages_pct then
      return 100;
  return 100*M/innodb_max_dirty_pages_pct;
}
```



* 1）参数 innodb_max_dirty_pages_pct 是脏页比例上限，默认值是 75%。
* 2）脏页比例是通过 `Innodb_buffer_pool_pages_dirty`/`Innodb_buffer_pool_pages_total` 得到的，具体的命令参考下面的代码：

```mysql
mysql> select VARIABLE_VALUE into @a from global_status where VARIABLE_NAME = 'Innodb_buffer_pool_pages_dirty';
select VARIABLE_VALUE into @b from global_status where VARIABLE_NAME = 'Innodb_buffer_pool_pages_total';
select @a/@b;
```





## 5. 小结

无论是你的查询语句在需要内存的时候可能要求淘汰一个脏页，还是由于刷脏页的逻辑会占用 IO 资源并可能影响到了你的更新语句，都可能是造成你从业务端感知到 MySQL“抖”了一下的原因。

刷脏页的时机：

* 1）redo log文件写满
  * redo log 是循环写的，写满后只能停下其他工作先将脏页刷盘（刷盘后对应的 redo log 就不需要保留了，等于是腾出了空间），如果不刷盘，那么 redo log 被覆盖后可能会出现数据丢失。
* 2）内存不足
  * 查询时需要将新页加载到内存中，若内存不足则只能将脏页刷盘以腾出空间
* 3）MySQL空闲
  * MySQL觉得系统空闲时也会执行脏页刷盘操作，反正闲着也是闲着
* 4）关闭MySQL
  * 关闭之前也会执行脏页刷盘操作

优化点：

* 1）正确设置 innodb_io_capacity 参数，一般建议设置为当前服务器的 IOPS
* 2）正确设置 innodb_flush_neighbors 参数
  * 机械硬盘建议设置为 1
  * SSD 建议设置为 0



刷脏页策略：

主要和脏页比例及 redo log 写盘速度有关，InnoDB 会根据这两个因素先单独算出两个数字。

* 1）InnoDB 会根据当前的脏页比例（假设为 M），算出一个范围在 0 到 100 之间的数字，记为 F1(M)。
* 2）第二个数字则是当前写入的序号跟 checkpoint 对应的序号之间的差值，假设为 N，InnoDB 会根据这个 N 算出一个范围在 0 到 100 之间的数字，这个计算公式可以记为 F2(N)。

**然后，根据上述算得的 F1(M) 和 F2(N) 两个值，取其中较大的值记为 R，之后引擎就可以按照 innodb_io_capacity 定义的能力乘以 R% 来控制刷脏页的速度。**
