# MySQL 加锁规则

> MySQL 后面的版本可能会改变加锁策略，所以这个规则只限于截止到现在的最新版本，即 5.x 系列 <=5.7.24，8.0 系列 <=8.0.13。

因为间隙锁在可重复读隔离级别下才有效，所以本篇文章接下来的描述，若没有特殊说明，默认是**可重复读隔离级别**。

包含了两个**原则**、两个**优化**和一个**bug**。

* 原则 1：加锁的基本单位是 next-key lock。希望你还记得，next-key lock 是前开后闭区间。
* 原则 2：查找过程中访问到的对象才会加锁。
* 优化 1：索引上的等值查询，给唯一索引加锁的时候，next-key lock 退化为行锁。
* 优化 2：索引上的等值查询，向右遍历时且最后一个值不满足等值条件的时候，next-key lock 退化为间隙锁。
* 一个 bug：唯一索引上的范围查询会访问到不满足条件的第一个值为止。
  * 在最新的 8.0.18 版本已经修复。



###  不等号条件里的等值查询

看下这个例子，分析一下这条查询语句的加锁范围：

```mysql
begin;
select * from t where id>9 and id<12 order by id desc for update;
```

利用上面的加锁规则，我们知道这个语句的加锁范围是主键索引上的 (0,5]、(5,10]和 (10, 15)。也就是说，id=15 这一行，并没有被加上行锁。为什么呢？

我们说加锁单位是 next-key lock，都是前开后闭区间，但是这里用到了优化 2，即索引上的等值查询，向右遍历的时候 id=15 不满足条件，所以 next-key lock 退化为了间隙锁 (10, 15)。

具体流程如下：

* 1）首先这个查询语句的语义是 order by id desc，要拿到满足条件的所有行，优化器必须先找到“第一个 id<12 的值”。
  * 如果是 order by id desc 就会找“第一个 id > 9 的值”
* 2）这个过程是通过索引树的搜索过程得到的，在引擎内部，其实是要找到 id=12 的这个值，只是最终没找到，但找到了 (10,15) 这个间隙。
  * 所以不等号的第一个值是通过等值查询来定位的
* 3）然后向左遍历，在遍历过程中，就不是等值查询了，会扫描到 id=5 这一行，所以会加一个 next-key lock (0,5]。



**在执行过程中，通过树搜索的方式定位记录的时候，用的是“等值查询”的方法。而第一个值找谁则和排序有关。**



### 等值查询的过程-加锁过程

下面这个语句的加锁范围是什么？

```mysql

begin;
select id from t where c in(5,20,10) lock in share mode;
```



这条 in 语句会使用索引 c 并且 rows=3，说明这三个值都是通过 B+ 树搜索定位的。

* 1）在查找 c=5 的时候，先锁住了 (0,5]。但是因为 c 不是唯一索引，为了确认还有没有别的记录 c=5，就要向右遍历，找到 c=10 才确认没有了，这个过程满足优化 2，所以加了间隙锁 (5,10)。
* 2）同样的，执行 c=10 这个逻辑的时候，加锁的范围是 (5,10] 和 (10,15)；
* 3）执行 c=20 这个逻辑的时候，加锁的范围是 (15,20] 和 (20,25)。

通过这个分析，我们可以知道，这条语句在索引 c 上加的三个记录锁的顺序是：先加 c=5 的记录锁，再加 c=10 的记录锁，最后加 c=20 的记录锁。

可以看出来：**这些锁是“在执行过程中一个一个加的”，而不是一次性加上去的。**

**死锁**

理解了这个加锁过程之后，我们就可以来分析下面例子中的死锁问题了。

如果同时有另外一个语句，是这么写的：

```mysql

select id from t where c in(5,20,10) order by c desc for update;
```

我们现在都知道间隙锁是不互锁的，但是这两条语句都会在索引 c 上的 c=5、10、20 这三行记录上加记录锁。

> 这里你需要注意一下，由于语句里面是 order by c desc， 这三个记录锁的加锁顺序，是先锁 c=20，然后 c=10，最后是 c=5。

也就是说，**这两条语句要加锁相同的资源，但是加锁顺序相反**。当这两条语句并发执行的时候，就可能出现死锁。



### 死锁

* 1）由于锁是一个个加的，要避免死锁，对同一组资源，要按照尽量相同的顺序访问；
* 2）在发生死锁的时刻，InnoDB 会选择一个回滚成本较低的语句进行回滚，以解除死锁。



### 锁等待-间隙定义

| SessionA                                                     | SessionB                                                     |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| begin;<br/>select * form t where id>10 and id <=15 for update; |                                                              |
|                                                              | delete from t where id =10;(Query OK)<br/> insert into t values(10,10,10);(blocked) |

可以看到，由于 session A 并没有锁住 c=10 这个记录，所以 session B 删除 id=10 这一行是可以的。但是之后，session B 再想 insert id=10 这一行回去就不行了。

原因：

由于 delete 操作把 id=10 这一行删掉了，原来的两个间隙 (5,10)、(10,15）变成了一个 (5,15)。

也就是说，**所谓“间隙”，其实根本就是由“这个间隙右边的那个记录”定义的**。