# join相关优化

## 1. Multi-Range Read

**What**

Multi-Range Read（MRR） 是一种将查询时的随机读转为顺序读的优化手段。

**Why**

那当然是磁盘的随机读比顺序读慢嘛。

我们都知道对除Id以外字段做范围查询时先走二级索引（如果有索引），然后根据主键id去主键索引树一条条查找，这个过程也叫做回表。

主键索引是按主键顺序排的，但是按二级索引范围查询出来的结果，主键不一定是顺序排列的，大多数情况下都是乱序的。

所以对主键索引来说每次查询都是随机读。

**How**

举个栗子

优化前：

* 1）根据查询条件在二级索引树中找到主键id；
* 2）去主键索引根据id找到对应数据；
* 3）重复步骤12直到查询出所有满足条件的行；

优化后：

* 1）根据二级索引，定位到满足条件的记录，将 id 值放入 read_rnd_buffer 中 ; 
* 2）将 read_rnd_buffer 中的 id 进行递增排序；
* 3）根据排序后的 id 数组，依次到主键 id 索引中查记录，并作为结果返回；

可以看到主要就是将id暂时存在到 read_rnd_buffer 中，将其排序后再去主键索引中查询。



**因为大多数的数据都是按照主键递增顺序插入得到的，所以我们可以认为，如果按照主键的递增顺序查询的话，对磁盘的读比较接近顺序读，能够提升读性能。**

另外需要说明的是，如果你想要稳定地使用 MRR 优化的话，需要设置`set optimizer_switch="mrr_cost_based=off"`。（官方文档的说法，是现在的优化器策略，判断消耗的时候，会更倾向于不使用 MRR，把 mrr_cost_based 设置为 off，就是固定使用 MRR 了。）

**MRR 能够提升性能的核心**在于，这条查询语句在索引 a 上做的是一个范围查询（也就是说，这是一个多值查询），可以得到足够多的主键 id。这样通过排序以后，再去主键索引查数据，才能体现出“顺序性”的优势。



## 2. Batched Key Access 算法

**What**

BKA 算法在MySQL 在 5.6 版本后开始引入，这个 BKA 算法，其实就是对 NLJ 算法的优化。

> 因为 NLJ 是先在驱动表中取一条数据然后去被驱动表中匹配的。这样的话就用不了前面的 MRR 优化了。
>
> 可以理解为用 BKA 算法替代 NLJ 算法。



**Why**

虽然 NLJ 因为可以用到被驱动表的索引，效率不错，但还是有进一步优化的空间，BKA 算法则是对其的一个优化，

使得优化后的 NLJ 也可以用到 MRR。

**How**

优化前：

从驱动表 t1，一行行地取出 a 的值，再到被驱动表 t2 去做 join。也就是说，对于表 t2 来说，每次都是匹配一个值。这时，MRR 的优势就用不上了

优化后：

先把表 t1 的数据取出来一部分，先放到一个临时内存 join_buffer中，这样就可以使用 MRR 进行优化了，将这部分数据排好序后再去t2中查询。



该算法需要手动开启，命令如下 

```mysql
set optimizer_switch='mrr=on,mrr_cost_based=off,batched_key_access=on';
```





## 3. BNL 算法的性能问题

之前说 InnoDB 的 LRU 算法的时候提到，由于 InnoDB 对 Bufffer Pool 的 LRU 算法做了优化，即：第一次从磁盘读入内存的数据页，会先放在 old 区域。如果 1 秒之后这个数据页不再被访问了，就不会被移动到 LRU 链表头部，这样对 Buffer Pool 的命中率影响就不大。

但是，如果一个使用 BNL 算法的 join 语句，多次扫描一个冷表，而且这个语句执行时间超过 1 秒，就会在再次扫描冷表的时候，把冷表的数据页移到 LRU 链表头部。

这种情况对应的，是冷表的数据量小于整个 Buffer Pool 的 3/8，能够完全放入 old 区域的情况。

如果这个冷表很大，就会出现另外一种情况：业务正常访问的数据页，没有机会进入 young 区域。

由于优化机制的存在，一个正常访问的数据页，要进入 young 区域，需要隔 1 秒后再次被访问到。但是，由于我们的 join 语句在循环读磁盘和淘汰内存页，进入 old 区域的数据页，很可能在 1 秒之内就被淘汰了。这样，就会导致这个 MySQL 实例的 Buffer Pool 在这段时间内，young 区域的数据页没有被合理地淘汰。

也就是说，这两种情况都会影响 Buffer Pool 的正常运作。

**大表 join 操作虽然对 IO 有影响，但是在语句执行结束后，对 IO 的影响也就结束了。但是，对 Buffer Pool 的影响就是持续性的，需要依靠后续的查询请求慢慢恢复内存命中率。**

> 为了减少这种影响，你可以考虑增大 join_buffer_size 的值，减少对被驱动表的扫描次数。

BNL 算法对系统的影响主要包括三个方面：

* 1）可能会多次扫描被驱动表，占用磁盘 IO 资源；
* 2）判断 join 条件需要执行 M*N 次对比（M、N 分别是两张表的行数），如果是大表就会占用非常多的 CPU 资源；
* 3）可能会导致 Buffer Pool 的热数据被淘汰，影响内存命中率。



## 4. BNL 转 BKA

BNL 算法对性能影响比较大，优化的常见做法是，**给被驱动表的 join 字段加上索引，把 BNL 算法转成 BKA 算法**。

但是，有时候你确实会碰到一些不适合在被驱动表上建索引的情况。比如下面这个语句：

```mysql
select * from t1 join t2 on (t1.b=t2.b) where t2.b>=1 and t2.b<=2000;
```

如果这条语句同时是一个低频的 SQL 语句，那么再为这个语句在表 t2 的字段 b 上创建一个索引就很浪费了。

但是，如果使用 BNL 算法来 join 的话，这个语句的执行流程是这样的：

* 1）把表 t1 的所有字段取出来，存入 join_buffer 中。这个表只有 1000 行，join_buffer_size 默认值是 256k，可以完全存入。
* 2）扫描表 t2，取出每一行数据跟 join_buffer 中的数据进行对比，
  * 如果不满足 t1.b=t2.b，则跳过；
  * 如果满足 t1.b=t2.b, 再判断其他条件，也就是是否满足 t2.b 处于[1,2000]的条件，如果是，就作为结果集的一部分返回，否则跳过。

对于表 t2 的每一行，判断 join 是否满足的时候，都需要遍历 join_buffer 中的所有行。因此判断等值条件的次数是 1000*100 万 =10 亿次，这个判断的工作量很大。

在表 t2 的字段 b 上创建索引会浪费资源，但是不创建索引的话这个语句的等值条件要判断 10 亿次，想想也是浪费。*那么，有没有两全其美的办法呢？*

**这时候，我们可以考虑使用临时表**。使用临时表的大致思路是：

* 1）把表 t2 中满足条件的数据放在临时表 tmp_t 中；
* 2）为了让 join 使用 BKA 算法，给临时表 tmp_t 的字段 b 加上索引；
* 3）让表 t1 和 tmp_t 做 join 操作。

此时，对应的 SQL 语句的写法如下：

```mysql
create temporary table temp_t(id int primary key, a int, b int, index(b))engine=innodb;

insert into temp_t select * from t2 where b>=1 and b<=2000;

select * from t1 join temp_t on (t1.b=temp_t.b);
```

我们一起看一下这个过程的消耗：

* 1）执行 insert 语句构造 temp_t 表并插入数据的过程中，对表 t2 做了全表扫描，这里扫描行数是 100 万。
* 2）之后的 join 语句，扫描表 t1，这里的扫描行数是 1000；join 比较过程中，做了 1000 次带索引的查询。相比于优化前的 join 语句需要做 10 亿次条件判断来说，这个优化效果还是很明显的。

总体来看，不论是在原表上加索引，还是用有索引的临时表，我们的思路都是让 join 语句能够用上被驱动表上的索引，来触发 BKA 算法，提升查询性能。