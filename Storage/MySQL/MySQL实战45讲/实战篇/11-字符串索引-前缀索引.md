# 字符串建立索引

## 1. 前缀索引

假设，你现在维护一个支持邮箱登录的系统，用户表是这么定义的：

```mysql

mysql> create table SUser(
ID bigint unsigned primary key,
email varchar(64), 
... 
)engine=innodb; 
```



为了便于查询，肯定需要在 email 列上建立索引：

```mysql
# index1 索引里面，包含了每个记录的整个字符串
mysql> alter table SUser add index index1(email);
# index2 索引里面，对于每个记录都是只取前 6 个字节
mysql> alter table SUser add index index2(email(6));
```



email(6) 这个索引结构中每个邮箱字段都只取前 6 个字节（即：zhangs），所以占用的空间会更小，这就是使用前缀索引的优势。但，这同时带来的损失是，可能会增加额外的记录扫描次数。

> 毕竟可能存在前几个字节相同，但是后几个字节不同的邮箱。

接下来，我们再看看下面这个语句，在这两个索引定义下分别是怎么执行的。



**如果使用的是 index1**（即 email 整个字符串的索引结构），执行顺序是这样的：

* 1）从 index1 索引树找到满足索引值是’zhangssxyz@xxx.com’的这条记录，取得 ID2 的值；、
* 2）到主键上查到主键值是 ID2 的行，判断 email 的值是正确的，将这行记录加入结果集；
* 3）取 index1 索引树上刚刚查到的位置的下一条记录，发现已经不满足 email='zhangssxyz@xxx.com’的条件了，循环结束。



**如果使用的是 index2**（即 email(6) 索引结构），执行顺序是这样的：

* 1）从 index2 索引树找到满足索引值是’zhangs’的记录，找到的第一个是 ID1；
* 2）到主键上查到主键值是 ID1 的行，判断出 email 的值不是’zhangssxyz@xxx.com’，这行记录丢弃；
* 3）取 index2 上刚刚查到的位置的下一条记录，发现仍然是’zhangs’，取出 ID2，再到 ID 索引上取整行然后判断，这次值对了，将这行记录加入结果集；
* 4）重复上一步，直到在 idxe2 上取到的值不是’zhangs’时，循环结束。

通过对比可以发现：**使用前缀索引后，`可能`会导致查询语句读数据的次数变多**。

**不过使用前缀索引，定义好长度，就可以做到既节省空间，又不用额外增加太多的查询成本。**



### 区分度

实际上，我们在建立索引时关注的是区分度，区分度越高越好。因为区分度越高，意味着重复的键值越少。

统计方法如下：

```mysql

mysql> select count(distinct email) as L from SUser;
```

然后，依次选取不同长度的前缀来看这个值，比如我们要看一下 4~7 个字节的前缀索引，可以用这个语句：

```mysql

mysql> select 
  count(distinct left(email,4)）as L4,
  count(distinct left(email,5)）as L5,
  count(distinct left(email,6)）as L6,
  count(distinct left(email,7)）as L7,
from SUser;
```

使用前缀索引很可能会损失区分度，所以你需要预先设定一个可以接受的损失比例，比如 5%。然后，在返回的 L4~L7 中，找出不小于 L * 95% 的值



### 前缀索引对覆盖索引的影响

* 1）由于前缀索引只包含了部分信息，所以无法使用覆盖索引。

* 2）即使前缀长度包含了完整信息，InnoDB 也会进行回表，因为系统并不确定前缀索引的定义是否截断了完整信息。
* 比如定义一个 index(email(100)),肯定没有这么长的邮箱，所以这个前缀索引也是包含了完整信息的，不过系统并不确定，依旧会执行一次回表。



## 2. 其他索引方式

像身份证数据这种，是有规律的，一共 18 位，其中前 6 位是地址码，所以同一个县的人的身份证号前 6 位一般会是相同的。

这时候前缀索引区分度就很低了，按照我们前面说的方法，可能你需要创建长度为 12 以上的前缀索引，才能够满足区分度要求。

> 但是，索引选取的越长，占用的磁盘空间就越大，相同的数据页能放下的索引值就越少，搜索的效率也就会越低。

这个时候可以尝试一下几种方法：

**第一种方式是使用倒序存储**。如果你存储身份证号的时候把它倒过来存，每次查询的时候，你可以这么写：

```mysql

mysql> select field_list from t where id_card = reverse('input_id_card_string');
```

由于身份证号的最后 6 位没有地址码这样的重复逻辑，所以最后这 6 位很可能就提供了足够的区分度。

> 当然了，实践中你不要忘记使用 count(distinct) 方法去做个验证。



**第二种方式是使用 hash 字段**。你可以在表上再创建一个整数字段，来保存身份证的校验码，同时在这个字段上创建索引。

然后每次插入新记录的时候，都同时用 crc32() 这个函数得到校验码填到这个新字段。由于校验码可能存在冲突，也就是说两个不同的身份证号通过 crc32() 函数得到的结果可能是相同的，所以你的查询语句 where 部分要判断 id_card 的值是否精确相同。

```sh
mysql> select field_list from t where id_card_crc=crc32('input_id_card_string') and id_card='input_id_card_string'
```

这样，索引的长度变成了 4 个字节，比原来小了很多。



**倒序存储和使用 hash 字段这两种方法的异同点:**

首先，它们的相同点是，都不支持范围查询。

不同点：

* 从占用的额外空间来看，**倒序存储方式在主键索引上，不会消耗额外的存储空间**，而 hash 字段方法需要增加一个字段。当然，倒序存储方式使用 4 个字节的前缀长度应该是不够的，如果再长一点，这个消耗跟额外这个 hash 字段也差不多抵消了。
* 在 CPU 消耗方面，倒序方式每次写和读的时候，都需要额外调用一次 reverse 函数，而 hash 字段的方式需要额外调用一次 crc32() 函数。如果只从这两个函数的计算复杂度来看的话，**reverse 函数额外消耗的 CPU 资源会更小些**。
* 从查询效率上看，**使用 hash 字段方式的查询性能相对更稳定一些**。因为 crc32 算出来的值虽然有冲突的概率，但是概率非常小，可以认为每次查询的平均扫描行数接近 1。而倒序存储方式毕竟还是用的前缀索引的方式，也就是说还是会增加扫描行数。



## 3. 小结

字符串字段创建索引的几种方式：

* 1）直接创建完整索引，这样可能比较占用空间；
* 2）创建前缀索引，节省空间，但会增加查询扫描次数，并且不能使用覆盖索引；
* 3）倒序存储，再创建前缀索引，用于绕过字符串本身前缀的区分度不够的问题；
* 4）创建 hash 字段索引，查询性能稳定，有额外的存储和计算消耗，跟第三种方式一样，都不支持范围扫描。

> 索引字段越大，每个数据页上能存储的数据就越少，导致性能越低，所以才需要想办法降低索引字段的长度。