# 什么时候会使用内部临时表？

## 1. 概述

之前分别提到了 sort buffer、内存临时表和 join buffer。

其中，我们在排序的时候用到了 sort buffer，在使用 join 语句的时候用到了 join buffer。

那么什么时候会用到内部临时表呢?



## 2. union 执行流程

用下面的表 t1 来举例。

```mysql
create table t1(id int primary key, a int, b int, index(a));
delimiter ;;
create procedure idata()
begin
  declare i int;

  set i=1;
  while(i<=1000)do
    insert into t1 values(i, i, i);
    set i=i+1;
  end while;
end;;
delimiter ;
call idata();
```

然后，我们执行下面这条语句：

```mysql
(select 1000 as f) union (select id from t1 order by id desc limit 2);
```

这条语句用到了 union，它的语义是，取这两个子查询结果的并集。并集的意思就是这两个集合加起来，重复的行只保留一行。

这里就会用到临时表。

这个语句的执行流程是这样的：

* 1）创建一个内存临时表，这个临时表只有一个整型字段 f，并且 f 是主键字段。
* 2）执行第一个子查询，得到 1000 这个值，并存入临时表中。
* 3）执行第二个子查询：
  * 拿到第一行 id=1000，试图插入临时表中。但由于 1000 这个值已经存在于临时表了，违反了唯一性约束，所以插入失败，然后继续执行；
  * 取到第二行 id=999，插入临时表成功。
* 4）从临时表中按行取出数据，返回结果，并删除临时表，结果中包含两行数据分别是 1000 和 999。

可以看到，这里的内存临时表起到了**暂存数据**的作用，而且计算过程还用上了临时表**主键 id 的唯一性约束**，实现了 union 的语义。

> 如果把上面这个语句中的 union 改成 union all 的话，就没有了“去重”的语义。这样执行的时候，不需要去重，也就不需要临时表了。



## 3. group by 执行流程

另外一个常见的使用临时表的例子是 group by，我们来看一下这个语句：

```mysql
select id%10 as m, count(*) as c from t1 group by m;
```

这个语句的逻辑是把表 t1 里的数据，按照 id%10 进行分组统计，并按照 m 的结果排序后输出。

这里同样会用到临时表

这个语句的执行流程是这样的：

* 1）创建内存临时表，表里有两个字段 m 和 c，主键是 m；
* 2）扫描表 t1 的索引 a，依次取出叶子节点上的 id 值，计算 id%10 的结果，记为 x；
  * 如果临时表中没有主键为 x 的行，就插入一个记录 (x,1);
  * 如果表中有主键为 x 的行，就将 x 这一行的 c 值加 1；
* 3）遍历完成后，再根据字段 m 做排序，得到结果集返回给客户端。

这个例子里由于临时表只有 10 行，内存可以放得下，因此全程只使用了内存临时表。如果数据量超过`tmp_table_size `限制则会使用磁盘临时表。

不论是使用内存临时表还是磁盘临时表，group by 逻辑都需要构造一个带唯一索引的表，执行代价都是比较高的。如何优化呢?

要解决 group by 语句的优化问题，你可以先想一下这个问题：

*执行 group by 语句为什么需要临时表？*

group by 的语义逻辑，是统计不同的值出现的个数。但是，由于每一行的 id%100 的结果是无序的，所以我们就需要有一个临时表，来记录并统计结果。

### group by 优化方法 -- 索引

*那么，如果扫描过程中可以保证出现的数据是有序的，是不是就简单了呢？*

InnoDB 的索引，就可以满足这个输入有序的条件。

在 MySQL 5.7 版本支持了 generated column 机制，用来实现列数据的关联更新。你可以用下面的方法创建一个列 z，然后在 z 列上创建一个索引。

> 如果是 MySQL 5.6 及之前的版本，你也可以创建普通列和索引，来解决这个问题



```mysql
alter table t1 add column z int generated always as(id % 100), add index(z);
```

这样，索引 z 上的数据就是有序的了。上面的 group by 语句就可以改成：

```mysql
select z, count(*) as c from t1 group by z;
```

这样优化后，这个语句的执行不再需要临时表，也不需要排序了。



### group by 优化方法 -- 直接排序

如果可以通过加索引来完成 group by 逻辑就再好不过了。但是，如果碰上不适合创建索引的场景，我们还是要老老实实做排序的。

**那么，这时候的 group by 要怎么优化呢？**

如果我们明明知道，一个 group by 语句中需要放到临时表上的数据量特别大，却还是要按照“先放到内存临时表，插入一部分数据后，发现内存临时表不够用了再转成磁盘临时表”，看上去就有点儿傻。

我们可以在 group by 语句中加入` SQL_BIG_RESULT` 这个提示（hint），就可以告诉优化器：这个语句涉及的数据量很大，请直接用磁盘临时表。

MySQL 的优化器一看，磁盘临时表是 B+ 树存储，存储效率不如数组来得高。

>  B+ 树 O(LogN) 数组为O(1)

所以，既然你告诉我数据量很大，那从磁盘空间考虑，还是直接用数组来存吧。

因此，下面这个语句

```mysql
select SQL_BIG_RESULT id%100 as m, count(*) as c from t1 group by m;
```

的执行流程就是这样的：

* 1）初始化 sort_buffer，确定放入一个整型字段，记为 m；
* 2）扫描表 t1 的索引 a，依次取出里面的 id 值, 将 id%100 的值存入 sort_buffer 中；
* 3）扫描完成后，对 sort_buffer 的字段 m 做排序（如果 sort_buffer 内存不够用，就会利用磁盘临时文件辅助排序）；
* 4）排序完成后，就得到了一个有序数组。



## 4. 小结

本文主要记录了 group by 的几种实现算法以及使用建议：

* 1）如果对 group by 语句的结果没有排序要求，要在语句后面加 order by null；
* 2）尽量让 group by 过程用上表的索引，确认方法是 explain 结果里没有 Using temporary 和 Using filesort；
* 3）如果 group by 需要统计的数据量不大，尽量只使用内存临时表；也可以通过适当调大 tmp_table_size 参数，来避免用到磁盘临时表；
* 4）如果数据量实在太大，使用 SQL_BIG_RESULT 这个提示，来告诉优化器直接使用排序算法得到 group by 的结果。

group by 的顺序：

* 1）创建一个内部临时表，初始化字段 a(分组字段) b(数量)
* 2）扫描表，一个个的判断，a字段值在临时表不存在，则插入(2,1)，如果存在，比如（2,1），则加1，成为（2,2）
* 3）分组之后，默认会进行排序，如果不需要顺序，用 order by null。
  * group by 默认会进行排序，也就是说不加 order by 也会排序
  * 所以需要加 order by null 使其不排序
  * MySQL 8.0 中的 group by 以及不会默认排序了