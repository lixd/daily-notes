# 读写分离的坑

## 1. 读写分离架构

读写分离的主要目标就是分摊主库的压力。读写分离常见的有两种架构：

* 一种是**客户端直连**，客户端（client）主动做负载均衡，这种模式下一般会把数据库的连接信息放在客户端的连接层。也就是说，由客户端来选择后端数据库进行查询。

* 另一种是 **proxy**，在 MySQL 和客户端之间有一个中间代理层 proxy，客户端只连接 proxy， 由 proxy 根据请求类型和上下文决定请求的分发路由。

两种架构的优缺点：

客户端直连方案，因为少了一层 proxy 转发，所以查询性能稍微好一点儿，并且整体架构简单，排查问题更方便。但是这种方案，由于要了解后端部署细节，所以在出现主备切换、库迁移等操作的时候，客户端都会感知到，并且需要调整数据库连接信息。

> 你可能会觉得这样客户端也太麻烦了，信息大量冗余，架构很丑。其实也未必，一般采用这样的架构，一定会伴随一个负责管理后端的组件，比如 Zookeeper，尽量让业务端只专注于业务逻辑开发。

带 proxy 的架构，对客户端比较友好。客户端不需要关注后端细节，连接维护、后端信息维护等工作，都是由 proxy 完成的。但这样的话，对后端维护团队的要求会更高。而且，proxy 也需要有高可用架构。因此，带 proxy 架构的整体就相对比较复杂。

> 具体选择哪个方案就取决于数据库团队提供的能力了。但目前看，**趋势是往带 proxy 的架构方向发展的**。



## 2. 过期读

不论使用哪种架构，都会碰到**过期读**问题：由于主从可能存在延迟，客户端执行完一个更新事务后马上发起查询，如果查询选择的是从库的话，就有可能读到刚刚的事务更新之前的状态。

虽然可以通过一些优化策略避免主从延迟，但是也无法100%避免。所以肯定会出现 过期读 问题，常见解决方案如下：

* 强制走主库方案；
* sleep 方案；
* 判断主备无延迟方案；
* 配合 semi-sync 方案；
* 等主库位点方案；
* 等 GTID 方案。



### 强制走主库方案

强制走主库方案其实就是，将查询请求做分类。通常情况下，我们可以将查询请求分为这么两类：

* 1）对于必须要拿到最新结果的请求，强制将其发到主库上。
  * 比如，在一个交易平台上，卖家发布商品以后，马上要返回主页面，看商品是否发布成功。那么，这个请求需要拿到最新的结果，就必须走主库。
* 2）对于可以读到旧数据的请求，才将其发到从库上。
  * 在这个交易平台上，买家来逛商铺页面，就算晚几秒看到最新发布的商品，也是可以接受的。那么，这类请求就可以走从库。

虽然这个方案有点畏难和取巧的意思，但其实这个方案是用得最多的。

> 如果是那种所有请求都需要最新数据的，就要放弃读写分离，所有读写压力都在主库，等同于放弃了扩展性。



### Sleep 方案

主库更新后，读从库之前先 sleep 一下。具体的方案就是，类似于执行一条 select sleep(1) 命令。

> 这个方案的假设是，大多数情况下主备延迟在 1 秒之内，做一个 sleep 可以有很大概率拿到最新的数据。

从严格意义上来说，这个方案存在的问题就是不精确：

* 1）如果这个查询请求本来 0.5 秒就可以在从库上拿到正确结果，也会等 1 秒；
* 2）如果延迟超过 1 秒，还是会出现过期读。





### 判断主备无延迟方案

要确保备库无延迟，通常有三种做法。

**第一种方法**是，每次从库执行查询请求前，先判断 seconds_behind_master 是否已经等于 0。如果还不等于 0 ，那就必须等到这个参数变为 0 才能执行查询请求。

> seconds_behind_master  单位是秒，精度可能不够。

**第二种方法**，对比位点确保主备无延迟：

* Master_Log_File 和 Read_Master_Log_Pos，表示的是读到的主库的最新位点；
* Relay_Master_Log_File 和 Exec_Master_Log_Pos，表示的是备库执行的最新位点。

如果 Master_Log_File 和 Relay_Master_Log_File、Read_Master_Log_Pos 和 Exec_Master_Log_Pos 这两组值完全相同，就表示接收到的日志已经同步完成。

**第三种方法**，对比 GTID 集合确保主备无延迟：

* Auto_Position=1 ，表示这对主备关系使用了 GTID 协议
* Retrieved_Gtid_Set，是备库收到的所有日志的 GTID 集合
* Executed_Gtid_Set，是备库所有已经执行完成的 GTID 集合。

如果这两个集合相同，也表示备库接收到的日志都已经同步完成。

其中对比位点和对比 GTID 这两种方法，都要比判断 seconds_behind_master 是否为 0 更准确。



依旧存在问题：**如果 binlog 都没有传给备库，那么备库根本不知道没同步完**。

* 对比位点确保主备无延迟方案中比较的是备库读取到的主库的位点和备库已经通过的位点。

* GTID 方案同样，是用备库收到的 GITD 集合 和 备库已执行的 GTID 集合比较。

这两个方案都**只能确保备库收到的 binlog 都执行了**，但是还没收到的就管不了了。



### 配合 semi-sync

要解决判断主备无延迟方案中的问题，就要引入**半同步复制**，也就是 semi-sync replication。

semi-sync 做了这样的设计：

* 1）事务提交的时候，主库把 binlog 发给其中一个从库；
* 2）该从库收到 binlog 以后，发回给主库一个 ack，表示收到了；
* 3）主库收到这个 ack 以后，才能给客户端返回“事务完成”的确认。

也就是说，如果启用了 semi-sync，就表示所有给客户端发送过确认的事务，都确保了至少一个备库已经收到了这个日志。

这样，semi-sync 配合前面关于位点的判断，就能够确定在从库上执行的查询请求，可以避免过期读。

> 不过，该方案只对一主一备的场景是成立的

在一主多从场景中，主库只要等到一个从库的 ack，就开始给客户端返回确认。这时，在从库上执行查询请求，就有两种情况：

* 1）如果查询是落在这个响应了 ack 的从库上，是能够确保读到最新数据
* 2）但如果是查询落到其他从库上，它们可能还没有收到最新的日志，就会产生过期读的问题。

而且，判断同步位点的方案还有另外一个潜在的问题，即：如果在业务更新的高峰期，主库的位点或者 GTID 集合更新很快，那么上面的两个位点等值判断就会一直不成立，很可能出现从库上迟迟无法响应查询请求的情况。



semi-sync 配合判断主备无延迟的方案，存在两个问题：

* 1）一主多从的时候，在某些从库执行查询请求会存在过期读的现象；
* 2）在持续延迟的情况下，可能出现过度等待的问题。



### 等主库位点方案

该方案可以解决emi-sync 配合判断主备无延迟的方案存在的两个问题。

该方案主要依赖下面这个命令：

```mysql
select master_pos_wait(file, pos[, timeout]);
```

这条命令的逻辑如下：

* 1）它是在从库执行的；
* 2）参数 file 和 pos 指的是主库上的文件名和位置；
* 3）timeout 可选，设置为正整数 N 表示这个函数最多等待 N 秒。

**这个命令正常返回的结果是一个正整数 M，表示从命令开始执行，到应用完 file 和 pos 表示的 binlog 位置，执行了多少事务**。

当然，除了正常返回一个正整数 M 外，这条命令还会返回一些其他结果，包括：

* 1）如果执行期间，备库同步线程发生异常，则返回 NULL；
* 2）如果等待超过 N 秒，就返回 -1；
* 3）如果刚开始执行的时候，就发现已经执行过这个位置了，则返回 0。

对于先执行 trx1，再执行一个查询请求的逻辑，要保证能够查到正确的数据，我们可以使用这个逻辑：

* 1）trx1 事务更新完成后，马上执行 show master status 得到当前主库执行到的 File 和 Position；
* 2）选定一个从库执行 select master_pos_wait(File, Position, 1)；
* 3）如果返回值是 >=0 的正整数，则在这个从库执行查询语句；
* 4）否则，到主库执行查询语句。

因为`select master_pos_wait(File, Position, 1)`语句如果返回个大于等于 0 的整数，就确保了从库上执行的这个查询结果一定包含了 trx1 的数据。



> 不过如果第二步命令超时了，就只能转到主库查询了,当然为了不增加主库压力，也可以根据业务做降级处理等等。



### GTID 方案

如果你的数据库开启了 GTID 模式，对应的也有等待 GTID 的方案。

```mysql
select wait_for_executed_gtid_set(gtid_set, 1);
```

这条命令的逻辑是：

* 1）等待，直到这个库执行的事务中包含传入的 gtid_set，返回 0；
* 2）超时返回 1。

这时，等 GTID 的执行流程就变成了：

* 1）trx1 事务更新完成后，从返回包直接获取这个事务的 GTID，记为 gtid1；
* 2）选定一个从库执行 select wait_for_executed_gtid_set(gtid1, 1)；
* 3）如果返回值是 0，则在这个从库执行查询语句；
* 4）否则，到主库执行查询语句。



> 跟等主库位点的方案一样，等待超时后也只能转移到主库进行查询。



在上面的第一步中，trx1 事务更新完成后，从返回包直接获取这个事务的 GTID。

*问题是，怎么能够让 MySQL 在执行事务后，返回包中带上 GTID 呢？*

你只需要将参数 session_track_gtids 设置为 OWN_GTID，然后通过 API 接口 `mysql_session_track_get_first` 从返回包解析出 GTID 的值即可。





## 3. 小结

本文主要介绍了读写分离架构下的坑：过期读，及其常见解决方案：

* 强制走主库方案；
* sleep 方案；
* 判断主备无延迟方案；
* 配合 semi-sync 方案；
* 等主库位点方案；
* 等 GTID 方案。

这几种方案中，有的方案看上去是做了妥协，有的方案看上去不那么靠谱儿，但都是有实际应用场景的，你需要根据业务需求选择。

其实，在实际应用中，这几个方案是可以混合使用的。

比如，先在客户端对请求做分类，区分哪些请求可以接受过期读，而哪些请求完全不能接受过期读；然后，对于不能接受过期读的语句，再使用等 GTID 或等位点的方案。