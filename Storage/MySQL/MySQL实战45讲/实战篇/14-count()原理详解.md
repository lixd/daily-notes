# count(*)这么慢，我该怎么办？



## 1. 表记录数获取方式

* 1）MyISAM 引擎把一个表的总行数存在了磁盘上，因此执行 count(*) 的时候会直接返回这个数，效率很高。
* 2）InnoDB 引擎则需要把数据一行一行地从引擎里面读出来，然后累积计数
* 3）show table status 中的 rows 字段
  * 该命令返回的 row 是使用采样统计获取到的，有很大误差，因此不能用于替代count（*）

**为什么 InnoDB 不把总行数存起来？**

**因为即使是在同一个时刻的多个查询，由于多版本并发控制（MVCC）的原因，InnoDB 表“应该返回多少行”也是不确定的**，InnoDB 只好把数据一行一行地读出依次判断，可见的行才能够用于计算“基于这个查询”的表的总行数。

你知道的，InnoDB 是索引组织表，主键索引树的叶子节点是数据，而普通索引树的叶子节点是主键值。所以，普通索引树比主键索引树小很多。对于 count(*) 这样的操作，遍历哪个索引树得到的结果逻辑上都是一样的。因此，MySQL 优化器会找到最小的那棵树来遍历。**在保证逻辑正确的前提下，尽量减少扫描的数据量，是数据库系统设计的通用法则之一**。



**小结**

* 1）MyISAM 表虽然 count(*) 很快，但是不支持事务；
* 2）InnoDB 表直接 count(*) 会遍历全表，虽然结果准确，但有性能问题。
* 3）show table status 命令虽然返回也很快，但是不准确；



## 2. 自定义存储方式

### 1. 缓存

将总记录数存储在缓存中，如 Redis,每次插入数据则Redis中计数+1。

> 看似美好，然则存在问题。

比如先插入数据，然后在增加计数，那么在这中间查询到的计数就是不对的，返过来先计数后插入数据也是一样的问题。

**这两个不同的存储构成的系统，不支持分布式事务，无法拿到精确一致的视图**

### 2. 数据库

直接在数据库中单独拿一张表来存储计数。

将增加计数操作和写入数据操作放在**事务**中，这样就是同一个存储系统没有分布式事务的问题了。

同样先插入数据，然后增加计数，由于事务的存在，在提交事务之前数据是对外不可见的，所以不会出现误差。



## 3. 不同count()的差异

count() 是一个聚合函数，对于返回的结果集，一行行地判断，**如果 count 函数的参数不是 NULL，累计值就加 1，否则不加**。最后返回累计值。

同样MySQL对count()函数做了一些优化：

* 1）server 层要什么就给什么；
* 2）InnoDB 只给必要的值；
* 3）优化了 count(*) 的语义为“取行数”，其他、的优化并没有做。



### 1. 对比

* 1）**count(主键id)**

InnoDB 引擎会遍历整张表，**把每一行的 id 值都取出来**，返回给 server 层。server 层拿到 id 后，主键id是肯定不可能为空的，也直接行累加。

* 2）**count(1)**

InnoDB 引擎遍历整张表，但**不取值**。server 层对于返回的每一行，放一个数字“1”进去（即判断1是否为null），很明显是不可能为空的，直接按行累加。

* 3）**count（字段）**

如果这个“字段”是定义为 not null 的话，一行行地从记录里面读出这个字段，不取值（因为not null现在肯定不会为null）判断不能为 null，按行累加；

如果这个“字段”定义允许为 null，那么执行的时候，判断到有可能是 null，**则需要取值**判断，不是 null 才累加。

* 4）**count(*)**

`count(*)` 是例外，并不会把全部字段取出来，而是专门做了优化，不取值。count(*) 肯定不是 null，按行累加。



### 2.结论

按照效率排序的话，count(字段)<count(主键 id)<count(1)≈`count(*)`，所以我建议你，尽量使用` count(*)`。



## 4. 小结

MyISAM 引擎把一个表的总行数存在了磁盘上，因此执行 count(*) 的时候会直接返回这个数，效率很高。

InnoDB 引擎则需要把数据一行一行地从引擎里面读出来，然后累积计数。

> 由于MVCC的原因，InnoDB 需要兼顾隔离性，所以 count 时也只能一行一行判断，只有当前可见的才会进行计数。

按照效率排序的话，count(字段)<count(主键 id)<count(1)≈`count(*)`，所以我建议你，尽量使用` count(*)`。

