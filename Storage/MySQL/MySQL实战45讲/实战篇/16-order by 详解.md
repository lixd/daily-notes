# orderby详解



## 0. 基本逻辑

* 1）MySQL会为每个线程分配一个内存（sort_buffer）用于排序，该内存大小为sort_buffer_size
  * 1）如果排序的数据量小于sort_buffer_size，排序将会在内存中完
  * 2）如果排序数据量很大，内存中无法存下这么多数据，则会使用磁盘临时文件来辅助排序，也称外部排序
  * 3）在使用外部排序时，MySQL会分成好几份单独的临时文件用来存放排序后的数据，然后在将这些文件合并成一个大文件

* 2）mysql会通过遍历索引将满足条件的数据读取到sort_buffer，并且按照排序字段进行快速排序
  * 1）如果查询的字段不包含在辅助索引中，需要按照辅助索引记录的主键返回聚集索引取出所需字段
  * 2）该方式会造成随机IO，在MySQL5.6提供了MRR的机制，会将辅助索引匹配记录的主键取出来在内存中进行排序，然后在回表
  * 3）按照情况建立联合索引来避免排序所带来的性能损耗，允许的情况下也可以建立覆盖索引来避免回表



拿下列语句举例

```mysql
CREATE TABLE `t` (
  `id` int(11) NOT NULL,
  `city` varchar(16) NOT NULL,
  `name` varchar(16) NOT NULL,
  `age` int(11) NOT NULL,
  `addr` varchar(128) DEFAULT NULL,
  PRIMARY KEY (`id`),
  KEY `city` (`city`)
) ENGINE=InnoDB;

select city,name,age from t where city='杭州' order by name limit 1000;
```



## 2. 算法详解

### 2.1 全字段排序

* 1）初始化 sort_buffer，确定放入 name、city、age 这三个字段；
* 2）从索引 city 找到第一个满足 city='杭州’条件的主键 id；
* 3）到主键 id 索引取出整行，取 name、city、age 三个字段的值，存入 sort_buffer 中；
* 4）从索引 city 取下一个记录的主键 id；
* 5）重复步骤 3、4 直到 city 的值不满足查询条件为止；
* 6）对 sort_buffer 中的数据按照字段 name 做快速排序；
* 7）按照排序结果取前 1000 行返回给客户端。

“按 name 排序”这个动作，可能在内存中完成，也可能需要使用外部排序，这取决于排序所需的内存和参数 `sort_buffer_size`。

如果要排序的数据量小于 sort_buffer_size，排序就在内存中完成。但如果排序数据量太大，内存放不下，则不得不利用磁盘临时文件辅助排序。

![](assets/全字段排序.webp)

### 2.2 rowid 排序

在上面这个算法过程里面，只对原表的数据读了一遍，剩下的操作都是在sort_buffer 和临时文件中执行的。

但这个算法有一个问题，就是如果查询要返回的字段很多的话，那么 sort_buffer 里面要放的字段数太多，这样内存里能够同时放下的行数很少，要分成很多个临时文件，排序的性能会很差。

**所以如果单行很大，全字段效率不够好。**

相关参数`max_length_for_sort_data `,是 MySQL 中专门控制用于排序的行数据的长度的一个参数。它的意思是，如果单行的长度超过这个值，MySQL 就认为单行太大，要换一个算法。

```mysql
# 修改为16
SET max_length_for_sort_data = 16;
```

新的算法放入 sort_buffer 的字段，**只有要排序的列（即 name 字段）和主键 id**。但这时，排序的结果就因为少了 city 和 age 字段的值，不能直接返回了，整个执行流程就变成如下所示的样子：

* 1）初始化 sort_buffer，确定放入两个字段，即 name 和 id；
* 2）从索引 city 找到第一个满足 city='杭州’条件的主键 id，也就是图中的 ID_X；
* 3）到主键 id 索引取出整行，取 name、id 这两个字段，存入 sort_buffer 中；
* 4）从索引 city 取下一个记录的主键 id；
* 5）重复步骤 3、4 直到不满足 city='杭州’条件为止，也就是图中的 ID_Y；
* 6）对 sort_buffer 中的数据按照字段 name 进行排序；
* 7）遍历排序结果，取前 1000 行，并按照 id 的值回到原表中取出 city、name 和 age 三个字段返回给客户端。

rowid 排序多访问了一次表 t 的主键索引，就是步骤 7。

![](assets/rowid 排序.webp)

需要说明的是，最后的“结果集”是一个逻辑概念，实际上 MySQL 服务端从排序后的 sort_buffer 中依次取出 id，然后到原表查到 city、name 和 age 这三个字段的结果，不需要在服务端再耗费内存存储结果，是直接返回给客户端的。



### 2.3 对比

**如果 MySQL 实在是担心排序内存太小，会影响排序效率，才会采用 rowid 排序算法**，这样排序过程中一次可以排序更多行，但是需要再回到原表去取数据。

**如果 MySQL 认为内存足够大，会优先选择全字段排序**，把需要的字段都放到 sort_buffer 中，这样排序后就会直接从内存里面返回查询结果了，不用再回到原表去取数据。

这也就体现了 MySQL 的一个设计思想：**如果内存够，就要多利用内存，尽量减少磁盘访问。**

* 对于 InnoDB 表来说，rowid 排序会要求回表多造成磁盘读，因此不会被优先选择。
* 对于内存表，回表过程只是简单地根据数据行的位置，直接访问内存得到数据，根本不会导致多访问磁盘。优化器没有了这一层顾虑，那么它会优先考虑的，就是用于排序的行越小越好了，所以，MySQL 这时就会选择 rowid 排序。

## 3. 优化

### 1. 排序字段联合索引

MySQL 之所以需要生成临时表，并且在临时表上做排序操作，其**原因是原来的数据都是无序的**。

如果将`where字段`和`orderby字段`建立`联合索引`,则取出来的数据天然就有序，则不需要排序过程了。

所以在前面表中创建一个 city 和 name 的联合索引，查询过程变成如下样子：

* 1）从索引 (city,name) 找到第一个满足 city='杭州’条件的主键 id；
* 2）到主键 id 索引取出整行，取 name、city、age 三个字段的值，作为结果集的一部分直接返回；
* 3）从索引 (city,name) 取下一个记录主键 id；
* 4）重复步骤 2、3，直到查到第 1000 条记录，或者是不满足 city='杭州’条件时循环结束。



### 2. 覆盖索引

针对这个查询，我们可以创建一个 city、name 和 age 的联合索引，其中city为where条件，name和age则是我们要查询的字段。

这个索引树上直接包含了这三个值，就不需要回表了。这样整个查询语句的执行流程就变成了：

* 1）从索引 (city,name,age) 找到第一个满足 city='杭州’条件的记录，取出其中的 city、name 和 age 这三个字段的值，作为结果集的一部分直接返回；
* 2）从索引 (city,name,age) 取下一个记录，同样取出这三个字段的值，作为结果集的一部分直接返回；
* 3）重复执行步骤 2，直到查到第 1000 条记录，或者是不满足 city='杭州’条件时循环结束。

当然，这里并不是说要为了每个查询能用上覆盖索引，就要把语句中涉及的字段都建上联合索引，毕竟索引还是有维护代价的。这是一个需要权衡的决定。



## 4. 小结

* **排序位置**：包括内存排序和文件排序，主要依据内存是否充足来选择。
* **排序算法**：包括 全字段排序和rowid排序，主要依据排序字段长度是否超过阈值判断。
* **相关优化**：有在排序字段上建立索引，直接省去排序过程和覆盖索引，减少回表过程。