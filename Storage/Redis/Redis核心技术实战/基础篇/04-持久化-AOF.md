# 持久化-AOF

## 1. 概述

Redis 作为一个内存数据库，响应速度非常快，但是也存在一个绝不能忽略的问题：**一旦服务器宕机，内存中的数据将全部丢失。**

所以 Redis 也提供了持久化功能，目前，Redis 的持久化主要有两大机制，即 **AOF（Append Only File）日志**和 **RDB(Redis DataBase) 快照**。



## 2. AOF 实现原理

### 写后日志

AOF 日志和 WAL(Write Ahead Log) 日志相反，为写后日志。“写后”的意思是 Redis 是先执行命令，把数据写入内存，然后才记录日志

*那 AOF 为什么要先执行命令再记日志呢？*

传统数据库的日志，例如 redo log（重做日志），记录的是修改后的数据，而 AOF 里记录的是 Redis 收到的每一条命令，这些命令是以文本形式保存的。

```sh
*3
$3
set
$7
testkey
$9
testvalue
```

“*3”表示当前命令有三个部分，每部分都是由“$+数字”开头，后面紧跟着具体的命令、键或值。这里，“数字”表示这部分中的命令、键或值一共有多少字节



为了避免额外的检查开销，Redis 在向 AOF 里面记录日志的时候，并不会先去对这些命令进行**语法检查**。所以，如果先记日志再执行命令的话，日志中就有可能记录了错误的命令，Redis 在使用日志恢复数据时，就可能会出错。

而写后日志这种方式，就是先让系统执行命令，只有命令能执行成功，才会被记录到日志中，否则，系统就会直接向客户端报错。所以，Redis 使用写后日志这一方式的一大好处是，**可以避免出现记录错误命令的情况**。

除此之外，AOF 还有一个好处：它是在命令执行后才记录日志，所以**不会阻塞当前的写操作**。



不过，AOF 也有两个潜在的风险。

首先，如果刚执行完一个命令，还没有来得及记日志就宕机了，那么这个命令和相应的数据就有丢失的风险。

其次，AOF 虽然避免了对当前命令的阻塞，但可能会给下一个操作带来阻塞风险。

> 这是因为，AOF 日志也是在主线程中执行的，如果在把日志文件写入磁盘时，磁盘写压力大，就会导致写盘很慢，进而导致后续的操作也无法执行了。

这两个风险都是和 AOF 写回磁盘的时机相关的，如果我们能够控制一个写命令执行完后 AOF 日志写回磁盘的时机，就能解除这两个风险。

### 写回策略

其实，对于这个问题，AOF 机制给我们提供了三个选择，也就是 AOF 配置项 `appendfsync` 的三个可选值。

* **Always**，同步写回：每个写命令执行完，立马同步地将日志写回磁盘
* **Everysec**，每秒写回：每个写命令执行完，只是先把日志写到 AOF 文件的内存缓冲区，每隔一秒把缓冲区中的内容写入磁盘；
* **No**，操作系统控制的写回：每个写命令执行完，只是先把日志写到 AOF 文件的内存缓冲区，由操作系统决定何时将缓冲区内容写回磁盘。



这三种写回策略都无法做到两全其美。我们来分析下其中的原因。

* “同步写回”可以做到基本不丢数据，但是它在每一个写命令后都有一个慢速的落盘操作，不可避免地会影响主线程性能；
* “操作系统控制的写回”虽然在写完缓冲区后，就可以继续执行后续的命令，但是落盘的时机已经不在 Redis 手中了，只要 AOF 记录没有写回磁盘，一旦宕机对应的数据就丢失了；
* “每秒写回”采用一秒写回一次的频率，避免了“同步写回”的性能开销，虽然减少了对系统性能的影响，但是如果发生宕机，上一秒内未落盘的命令操作仍然会丢失。所以，这只能算是，在避免影响主线程性能和避免数据丢失两者间取了个折中。



| 配置项   | 写回时机           | 优点                     | 缺点                             |
| -------- | ------------------ | ------------------------ | -------------------------------- |
| Always   | 同步写回           | 可靠性高，数据基本不丢失 | 每个写命令都要落盘，性能影响较大 |
| Everysec | 每秒写回           | 性能适中                 | 宕机时丢失1秒内的数据            |
| No       | 由操作系统控制写回 | 性能好                   | 宕机时丢失数据较多               |


总结一下就是：

* 想要获得高性能，就选择 No 策略；

* 如果想要得到高可靠性保证，就选择 Always 策略；

* 如果允许数据有一点丢失，又希望性能别受太大影响的话，那么就选择 Everysec 策略。



## 3. AOF 重写机制

### 重写原理

AOF 是以文件的形式在记录接收到的所有写命令。随着接收的写命令越来越多，AOF 文件会越来越大。这也就意味着，我们一定要小心 **AOF 文件过大带来的性能问题**。

* 1）文件系统本身对文件大小有限制，无法保存过大的文件；
* 2）如果文件太大，之后再往里面追加命令记录的话，效率也会变低；
* 3）如果发生宕机，AOF 中记录的命令要一个个被重新执行，用于故障恢复，如果日志文件太大，整个恢复过程就会非常缓慢，这就会影响到 Redis 的正常使用。

Redis AOF 重新机制就是用于解决该问题。

AOF 重写机制就是**根据数据库的现状创建一个新的 AOF 文件**，也就是说，读取数据库中的所有键值对，然后对每一个键值对用一条命令记录它的写入。

> 比如说，当读取了键值对“testkey”: “testvalue”之后，重写机制会记录 set testkey testvalue 这条命令。
>
> 相比之下感觉叫做 AOF 替换更好理解。



*为什么重写机制可以把日志文件变小呢?*

AOF 文件是以追加的方式，逐一记录接收到的写命令的。**当一个键值对被多条写命令反复修改时，AOF 文件会记录相应的多条命令**。但是，在重写的时候，是根据这个键值对当前的最新状态，为它生成对应的写入命令。

> 相当于对同一个 Key 更新了 N 次就会有 N 条日志，重写的时候就只需要写入最新的一条即可。

### bgrewriteaof 

*AOF 重写会阻塞吗?*

虽然 AOF 重写后，日志文件会缩小，但是，要把整个数据库的最新数据的操作日志都写回磁盘，仍然是一个非常耗时的过程。这时，我们就要继续关注另一个问题了：重写会不会阻塞主线程？

和 AOF 日志由主线程写回不同，重写过程是由后台子进程 bgrewriteaof 来完成的，这也是为了避免阻塞主线程，导致数据库性能下降。

我把重写的过程总结为“**一个拷贝，两处日志**”。

<img src="assets/AOF非阻塞的重写过程.webp"  />

“一个拷贝”就是指，每次执行重写时，主线程 fork 出后台的 bgrewriteaof 子进程。此时，fork 会把主线程的内存拷贝一份给 bgrewriteaof 子进程，这里面就包含了数据库的最新数据。然后，bgrewriteaof 子进程就可以在不影响主线程的情况下，逐一把拷贝的数据写成操作，记入重写日志。



“两处日志”又是什么呢？

* 第一处日志就是指**正在使用的 AOF 日志**，Redis 会把这个操作写到它的缓冲区。这样一来，即使宕机了，这个 AOF 日志的操作仍然是齐全的，可以用于恢复。
* 第二处日志，就是指**新的 AOF 重写日志**。这个操作也会被写到重写日志的缓冲区。这样，重写日志也不会丢失最新的操作。等到拷贝数据的所有操作记录重写完成后，重写日志记录的这些最新操作也会写入新的 AOF 文件，以保证数据库最新状态的记录。此时，我们就可以用新的 AOF 文件替代旧文件了。

总结来说，每次 AOF 重写时，Redis 会先执行一个内存拷贝，用于重写；然后，使用两个日志保证在重写过程中，新写入的数据不会丢失。而且，因为 **Redis 采用额外的线程进行数据重写**，所以，这个过程并**不会阻塞主线程**。

### 具体流程



* 1）fork出子进程，（使用写时复制(Copy On Write)机制避免一次性拷贝大量数据），将Redis中的所有数据写入新AOF文件
* 2）同时记录新收到的命令到AOF缓冲并写入旧AOF文件，保证旧AOF文件完整性
* 3）额外为本次AOF重写过程记录一份新收到的命令并写入AOF重写缓冲，等子进程完成后由主进程将该缓冲区数据追加到新AOF文件
* 4子进程重写完成后则通知主进程执行3中的追加操作
* 5）用新AOF文件替换旧文件
* 6）如果重写过程失败则直接删除新AOF文件和AOF重新缓冲区，继续使用旧AOF即可，这也是为什么需要保证旧AOF文件的完整性



### 文件切换

当子进程完成重写工作时，它给父进程发送一个信号，父进程在接收到信号之后，将`AOF重写缓冲`中的所有数据追加到**新 AOF 文件**的末尾。

然后 Redis 原子地用新文件替换旧文件，之后所有命令都会直接追加到新 AOF 文件的末尾



### 触发机制

AOF重写主要和`auto-aof-rewrite-min-size`和`auto-aof-rewrite-percentage`这两个配置有关

* auto-aof-rewrite-min-size：表示运行AOF重写时文件的最小大小，默认为64MB
* auto-aof-rewrite-percentage：这个值的计算方法是：当前AOF文件大小和上一次重写后AOF文件大小的差值，再除以上一次重写后AOF文件大小。也就是当前AOF文件比上一次重写后AOF文件的增量大小，和上一次重写后AOF文件大小的比值。

AOF文件大小**同时**超出上面这两个配置项时，会触发AOF重写。



## 4. 小结

* 1）AOF（Append Only File）日志：通过逐一记录操作命令，在恢复时再逐一执行命令的方式，保证了数据的可靠性。
* 2）在可靠性和性能之前的取舍，提供了 AOF 日志的三种写回策略，分别是 Always、Everysec 和 No，这三种策略在可靠性上是从高到低，而在性能上则是从低到高。
* 3）AOF 重写机制，直接根据数据库里数据的最新状态，生成这些数据的插入命令，作为新日志以降低 AOF 日志文件大小，同时这个过程通过后台线程完成，避免了对主线程的阻塞。

AOF重写的是为什么需要分别写AOF重写缓冲和AOF缓冲，不能共用一个文件吗？

* 1.主、子进程共用一个文件必定会产生竞争，控制竞争就意味着会影响父进程的性能
* 2.如果AOF重写过程中失败了，那么原本的AOF文件相当于被污染了，无法做恢复使用，分开写两个文件的话直接把AOF重写缓冲文件删掉即可。

AOF重写由子进程完成，那么有没有可能对主进程造成阻塞呢?

* 1.fork子进程时必定会阻塞
  * fork采用操作系统提供的写时复制(Copy On Write)机制，避免了同时拷贝太多内存数据给子进程，从而造成阻塞问题
  * 但fork子进程需要拷贝进程必要的数据结构，一个是进程控制块（Process Control Block，简称为 PCB），另外还有一项就是拷贝内存页表（虚拟内存和物理内存的映射索引表），这个拷贝过程会消耗大量CPU资源，拷贝完成之前整个进程是会阻塞的，阻塞时间取决于整个实例的内存大小，实例越大，内存页表越大，fork阻塞时间越久。
* 2.写时复制(Copy On Write)机制
  * fork子进程后，主子进程共用一块内存区域
  * 主进程若对该区域进行写操作，则会触发复制，将写的数据单独复制出来，与子进程分开，父子进程逐渐拥有各自独立的内存空间
  * 因为内存分配是以页为单位进行分配的，默认4k，如果父进程此时操作的是一个bigkey，重新申请大块内存耗时会变长，可能会产阻塞风险。
  * 另外，如果操作系统开启了内存大页机制(Huge Page，页面大小2M)，那么父进程申请内存时阻塞的概率将会大大提高，所以在Redis机器上需要关闭Huge Page机制。