# 数据结构

## 1. 概述

数据库这么多，为啥 Redis 能有这么突出的表现呢？一方面，这是因为它是内存数据库，所有操作都在内存上完成，内存的访问速度本身就很快。另一方面，这要归功于它的数据结构。



Redis 基本数据类型String（字符串）、List（列表）、Hash（哈希）、Set（集合）和 Sorted Set（有序集合）。

底层数据结构一共有 6 种，分别是简单动态字符串、双向链表、压缩列表、哈希表、跳表和整数数组。

![](assets/数据类型和底层结构对应关系.webp)

看到这里，其实有些问题已经值得我们去考虑了：

* 这些数据结构都是值的底层实现，键和值本身之间用什么结构组织？
* 为什么集合类型有那么多的底层结构，它们都是怎么组织数据的，都很快吗？
* 什么是简单动态字符串，和常用的字符串是一回事吗？





## 2. 全局哈希表

为了实现从键到值的快速访问，Redis 使用了一个**哈希表**来保存所有键值对。同时哈希桶中的元素保存的并不是值本身，而是指向具体值的**指针**。

> 使用指针就可以同时兼容 String 和集合类型。

因为这个哈希表保存了所有的键值对，所以，我也把它称为**全局哈希表**。

哈希表的最大好处很明显，就是让我们可以用**O(1) **的时间复杂度来快速查找到键值对。

> 我们只需要计算键的哈希值，就可以知道它所对应的哈希桶位置，然后就可以访问相应的 entry 元素。

Hash表存在潜在的风险点，那就是哈希表的**冲突**问题和 **rehash** 可能带来的操作阻塞。

### 哈希冲突

哈希冲突：指两个 key 的哈希值和哈希桶计算对应关系时，正好落在了同一个哈希桶中。

当你往哈希表中写入更多数据时，哈希冲突是不可避免的问题。

> 毕竟，哈希桶的个数通常要少于 key 的数量，这也就是说，难免会有一些 key 的哈希值对应到了同一个哈希桶中。

Redis 解决哈希冲突的方式，就是**链式哈希**。指**同一个哈希桶中的多个元素用一个链表来保存，它们之间依次用指针连接**。



### Rehash

哈希冲突链上的元素只能通过指针逐一查找再操作。如果某个哈希冲突链过长，就会导致这个链上的元素查找耗时长，效率降低。

所以，Redis 会对哈希表做 **rehash** 操作。**rehash 也就是增加现有的哈希桶数量，让逐渐增多的 entry 元素能在更多的桶之间分散保存，从而减少单个桶中的冲突**。

**为了使 rehash 操作更高效，Redis 默认使用了两个全局哈希表**：哈希表 1 和哈希表 2。一开始，当你刚插入数据时，默认使用哈希表 1，此时的哈希表 2 并没有被分配空间。随着数据逐步增多，Redis 开始执行 rehash，这个过程分为三步：

* 1）给哈希表 2 分配更大的空间，例如是当前哈希表 1 大小的两倍；
* 2）把哈希表 1 中的数据重新映射并拷贝到哈希表 2 中；
* 3）释放哈希表 1 的空间。

到此，我们就可以从哈希表 1 切换到哈希表 2，用增大的哈希表 2 保存更多数据，而原来的哈希表 1 留作下一次 rehash 扩容备用。

二步涉及大量的数据拷贝，如果一次性把哈希表 1 中的数据都迁移完，会造成 Redis 线程阻塞，为了避免这个问题，Redis 采用了**渐进式 rehash**。

简单来说就是：

Redis 仍然正常处理客户端请求，每处理一个请求时，从哈希表 1 中的第一个索引位置开始，顺带着将这个索引位置上的所有 entries 拷贝到哈希表 2 中；等处理下一个请求时，再顺带拷贝哈希表 1 中的下一个索引位置的 entries。

这样就巧妙地把一次性大量拷贝的开销，分摊到了多次处理请求的过程中，避免了耗时操作，保证了数据的快速访问。



## 3. 数据类型

### String

对于 String 类型来说，找到哈希桶就能直接增删改查了，所以，哈希表的 O(1) 操作复杂度也就是它的复杂度了。但是，对于集合类型来说，即使找到哈希桶了，还要在集合中再进一步操作



### 集合类型

集合类型的值，第一步是通过全局哈希表找到对应的哈希桶位置，第二步是在集合中再增删改查。

集合类型的底层数据结构主要有 5 种：整数数组、双向链表、哈希表、压缩列表和跳表。