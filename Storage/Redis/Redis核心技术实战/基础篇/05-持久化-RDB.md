# 持久化-RDB

## 1. 概述

因为记录的是操作命令，而不是实际的数据，所以，用 AOF 方法进行故障恢复的时候，需要逐一把操作日志都执行一遍。

**如果操作日志非常多，Redis 就会恢复得很缓慢**，影响到正常使用。这当然不是理想的结果。

于是 Redis 又出现了另一种持久化方式**RDB(Redis DataBase)内存快照**。

所谓内存快照，就是指内存中的数据在某一个时刻的状态记录

对 Redis 来说，它实现类似照片记录效果的方式，就是把某一时刻的状态以文件的形式写到磁盘上，也就是快照。这样一来，即使宕机，快照文件也不会丢失，数据的可靠性也就得到了保证。这个快照文件就称为 RDB 文件。

和 AOF 相比，**RDB 记录的是某一时刻的数据**，并不是操作，所以，在做数据恢复时，我们可以直接把 RDB 文件读入内存，**很快地完成恢复**。





## 2. 给哪些内存数据做快照？

Redis 的数据都在内存中，为了提供所有数据的可靠性保证，它执行的是**全量快照**。

给内存的全量数据做快照，把它们全部写入磁盘也会花费很多时间。而且，全量数据越多，RDB 文件就越大，往磁盘上写数据的时间开销就越大。



## 3. 它会阻塞主线程吗

Redis 提供了两个命令来生成 RDB 文件，分别是 save 和 bgsave。

* save：在主线程中执行，会导致阻塞；
* bgsave：创建一个子进程，专门用于写入 RDB 文件，避免了主线程的阻塞，这也是 Redis RDB 文件生成的默认配置。



## 4. 快照时数据能修改吗?

在给别人拍照时，一旦对方动了，那么这张照片就拍糊了，我们就需要重拍，所以我们当然希望对方保持不动。对于内存快照而言，我们也不希望数据“动”。

但是，如果快照执行期间数据不能被修改，意味着 Redis 在这段时间不能处理写操作，那无疑就会给业务服务造成巨大的影响。

为了避免快照时无法处理写操作，Redis 就会借助操作系统提供的**写时复制技术（Copy-On-Write, COW）**，在执行快照的同时，正常处理写操作。

简单来说，bgsave 子进程是由主线程 fork 生成的，可以共享主线程的所有内存数据。bgsave 子进程运行后，开始读取主线程的内存数据，并把它们写入 RDB 文件。

此时，如果主线程对这些数据也都是读操作（例如图中的键值对 A），那么，主线程和 bgsave 子进程相互不影响。但是，如果主线程要修改一块数据（例如图中的键值对 C），那么，这块数据就会被复制一份，生成该数据的副本（键值对 C’）。然后，主线程在这个数据副本上进行修改。同时，bgsave 子进程可以继续把原来的数据（键值对 C）写入 RDB 文件。

![](assets/写时复制机制保证快照期间数据可修改.jpg)



这既保证了快照的完整性，也允许主线程同时对数据进行修改，避免了对正常业务的影响。这既保证了快照的完整性，也允许主线程同时对数据进行修改，避免了对正常业务的影响。



## 5. 快照频率

> 和 AOF 的写回策略一样，快照频率也是在可靠性和性能之间的取舍。

为了防止宕机后数据丢失，按理说应该将快照的间隔时间变得很短，这一即使某一时刻发生宕机了，因为上一时刻快照刚执行，丢失的数据也不会太多。

这种想法其实是错误的。虽然 bgsave 执行时不阻塞主线程，但是，**如果频繁地执行全量快照，也会带来两方面的开销**。

* 一方面，频繁将全量数据写入磁盘，会给磁盘带来很大压力，多个快照竞争有限的磁盘带宽，前一个快照还没有做完，后一个又开始做了，容易造成恶性循环。
* 另一方面，bgsave 子进程需要通过 fork 操作从主线程创建出来。虽然，子进程在创建后不会再阻塞主线程，但是，fork 这个创建过程本身会阻塞主线程，而且主线程的内存越大，阻塞时间越长。如果频繁 fork 出 bgsave 子进程，这就会频繁阻塞主线程了。
  * 所以，在 Redis 中如果有一个 bgsave 在运行，就不会再启动第二个 bgsave 子进程

*那么，有什么其他好方法吗？*

### 增量快照

此时，我们可以做**增量快照**，所谓增量快照，就是指，**做了一次全量快照后，后续的快照只对修改的数据进行快照记录**，这样可以避免每次全量快照的开销。

增量快照的前提是，**我们需要记住哪些数据被修改了**。

如果我们对每一个键值对的修改，都做个记录，那么，如果有 1 万个被修改的键值对，我们就需要有 1 万条额外的记录。而且，有的时候，键值对非常小，比如只有 32 字节，而记录它被修改的元数据信息，可能就需要 8 字节，这样的话，**为了“记住”修改，引入的额外空间开销比较大。这对于内存资源宝贵的 Redis 来说，有些得不偿失**。

> 所以 Redis 未采取 增量快照的方案。

### 混合使用 AOF 日志和内存快照

*那么，还有什么方法既能利用 RDB 的快速恢复，又能以较小的开销做到尽量少丢数据呢？*

虽然跟 AOF 相比，快照的恢复速度快，但是，快照的频率不好把握，如果频率太低，两次快照间一旦宕机，就可能有比较多的数据丢失。如果频率太高，又会产生额外开销。

Redis 4.0 中提出了一个**混合使用 AOF 日志和内存快照的方法**。简单来说，内存快照以一定的频率执行，在两次快照之间，使用 AOF 日志记录这期间的所有命令操作。

这样一来，快照不用很频繁地执行，这就避免了频繁 fork 对主线程的影响。而且，AOF 日志也只用记录两次快照间的操作，也就是说，不需要记录所有操作了，因此，就不会出现文件过大的情况了，也可以避免重写开销。

如下图所示，T1 和 T2 时刻的修改，用 AOF 日志记录，等到第二次做全量快照时，就可以清空 AOF 日志，因为此时的修改都已经记录到快照中了，恢复时就不再用日志了。

![](assets/内存快照和AOF混合使用.webp)

这个方法既能享受到 RDB 文件快速恢复的好处，又能享受到 AOF 只记录操作命令的简单优势，颇有点“鱼和熊掌可以兼得”的感觉。



## 6. 小结

* 1）RDB 全量快照，恢复速度快，但是快照消耗大，频繁快照是不太能接受的。
* 2）save 在主线程生成 RDB 文件，会阻塞主线程，bgsave 创建一个子进程，专门用于写入 RDB 文件，避免了主线程的阻塞。
* 3）快照频率高影响性能，频率低又会丢较多数据，Redis 4.0 推出 混合使用 AOF 日志和内存快照的方法。再两次快照间使用 AOF 来记录写操作，保证数据不丢。

最后，关于 AOF 和 RDB 的选择问题，建议如下：

* 数据不能丢失时，内存快照和 AOF 的混合使用是一个很好的选择；
* 如果允许分钟级别的数据丢失，可以只使用 RDB；
* 如果只用 AOF，优先使用 everysec 的配置选项，因为它在可靠性和性能之间取了一个平衡。