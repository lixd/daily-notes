# 数据分布优化：如何应对数据倾斜？

## 1. 概述

在切片集群中，数据会按照一定的分布规则分散到不同的实例上保存。比如，在使用 Redis Cluster 时，数据都会先按照 CRC 算法的计算值对 Slot（逻辑槽）取模，同时，所有的 Slot 又会由运维管理员分配到不同的实例上。这样，数据就被保存到相应的实例上了。

虽然这种方法实现起来比较简单，但是很容易导致一个问题：**数据倾斜**。

数据倾斜有两类。

* **数据量倾斜**：在某些情况下，实例上的数据分布不均衡，某个实例上的数据特别多。
* **数据访问倾斜**：虽然每个集群实例上的数据量相差不大，但是某个实例上的数据是热点数据，被访问得非常频繁。



## 2. 数据量倾斜的成因和应对方法

### 2.1 bigkey 导致倾斜

**第一个原因**：某个实例上正好保存了 bigkey，那么必然出现数据倾斜。

解决方案：

* 1）在业务层生成数据时，要尽量避免把过多的数据保存在同一个键值对中。

* 2）如果 bigkey 正好是集合类型可以把 bigkey 拆分成很多个小的集合类型数据，分散保存在不同的实例上。



### 2.2 Slot 分配不均衡导致倾斜

如果集群运维人员没有均衡地分配 Slot，就会有大量的数据被分配到同一个 Slot 中，而同一个 Slot 只会在一个实例上分布，这就会导致，大量数据被集中到一个实例上，造成数据倾斜。

解决方案：

* 1）我们可以通过运维规范，在分配之前，我们就要避免把过多的 Slot 分配到同一个实例。
* 2）如果是已经分配好 Slot 的集群，我们可以先查看 Slot 和实例的具体分配关系，从而判断是否有过多的 Slot 集中到了同一个实例。如果有的话，就将部分 Slot 迁移到其它实例，从而避免数据倾斜。



### 2.3 Hash Tag 导致倾斜

Hash Tag 是指加在键值对 key 中的一对花括号{}。这对括号会把 key 的一部分括起来，**客户端在计算 key 的 CRC16 值时，只对 Hash Tag 花括号中的 key 内容进行计算**。如果没用 Hash Tag 的话，客户端计算整个 key 的 CRC16 的值。

举个例子，假设 key 是 `user:profile:3231`，我们把其中的 3231 作为 Hash Tag，此时，key 就变成了 `user:profile:{3231}`。当客户端计算这个 key 的 CRC16 值时，就只会计算 `3231` 的 CRC16 值。

使用 Hash Tag 的好处是，如果不同 key 的 Hash Tag 内容都是一样的，那么，这些 key 对应的数据会被映射到同一个 Slot 中，同时会被分配到同一个实例上。

> Hash Tag 把要执行事务操作或是范围查询的数据映射到同一个实例上，这样就能很轻松地实现事务或范围查询了。



但是，使用 Hash Tag 的潜在问题，就是大量的数据可能被集中到一个实例上，导致数据倾斜，集群中的负载不均衡。

解决方案：

如果使用 Hash Tag 进行切片的数据会带来较大的访问压力，就优先考虑避免数据倾斜，最好不要使用 Hash Tag 进行数据切片。



## 3. 数据访问倾斜的成因和应对方法

和数据量倾斜不同，热点数据通常是一个或几个数据，所以，直接重新分配 Slot 并不能解决热点数据的问题。

通常来说，热点数据以服务读操作为主，在这种情况下，我们可以采用**热点数据多副本**的方法来应对。

这个方法的具体做法是，我们把热点数据复制多份，在每一个数据副本的 key 中增加一个随机前缀，让它和其它副本数据不会被映射到同一个 Slot 中。

当然也可以将 RedisCache 直接存到进程里，采用 LocalCache 方式来降低 Redis 压力。

注意：**热点数据多副本方法只能针对只读的热点数据**。

> 如果热点数据是有读有写的话，就不适合采用多副本方法了，因为要保证多副本间的数据一致性，会带来额外的开销。







## 4. 小结

| 倾斜类型     | 倾斜原因                                  | 应对方法                                                     |
| ------------ | ----------------------------------------- | ------------------------------------------------------------ |
| 数据量倾斜   | 存在bigkey                                | 业务层避免创建 bigkey<br/>把集合类型的 bigkey 拆分为多个小集合，分散保存 |
| 数据量倾斜   | Slot 分配不均                             | 制定运维规范，避免把过多 Solt 分配到一个实例                 |
| 数据量倾斜   | 使用 Hash Tag 导致大量数据集中到一个 Slot | 如果Hash Tag会造成数据倾斜，优先避免数据倾斜，不使用 Hash Tag |
| 数据访问倾斜 | 存在热点数据                              | 采用带有不同Key前缀的多副本方法<br/>将 RedisCache 提升为 LocalCache，存入进程中以降低 Redis 压力 |

