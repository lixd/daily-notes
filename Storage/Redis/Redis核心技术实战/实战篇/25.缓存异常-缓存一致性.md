# 如何解决缓存和数据库的数据不一致问题？

## 1. 概述

缓存异常问题，概况来说包含 4 个方面：

* 1）缓存中的数据和数据库中的不一致；
* 2）缓存雪崩；
* 3）缓存击穿
* 4）缓存穿透。



## 2. 缓存不一致

只要我们使用 Redis 缓存，就必然会面对缓存和数据库间的一致性保证问题。

这里的“一致性”包含了两种情况：

* 缓存中有数据，那么，缓存的数据值需要和数据库中的值相同；
* 缓存中本身没有数据，那么，数据库中的值必须是最新值。

不符合这两种情况的，就属于缓存和数据库的数据不一致问题了。

另外当缓存的读写模式不同时，缓存数据不一致的发生情况不一样，我们的应对方法也会有所不同。

### 读写缓存



* 同步直写策略：写缓存时，也同步写数据库，缓存和数据库中的数据一致；
* 异步写回策略：写缓存时不同步写数据库，等到数据从缓存中淘汰时，再写回数据库。使用这种策略时，如果数据还没有写回数据库，缓存就发生了故障，那么，此时，数据库就没有最新的数据了。

对于读写缓存来说，要想保证缓存和数据库中的数据一致，就要采用**同步直写策略**。

> 需要保证缓存和数据库的更新具有原子性。如果缓存和数据库的更新不是原子性，必定会导致缓存一致性问题。



### 只读缓存

对于只读缓存来说：

* 如果有数据新增，会直接写入数据库；
* 而有数据删改时，就需要把只读缓存中的数据标记为无效。等后续请求发生缓存缺失时，应用再从数据库中把数据读入缓存。

> 同样需要保证更新数据库和删除缓存数据两个操作的原子性。



更新数据库 和 删除缓存两个操作顺序不同也会造成不同的结果：



| 不同情况               | 潜在问题                                                     |
| ---------------------- | ------------------------------------------------------------ |
| 先删缓存后更新数据库   | 数据库更新失败，导致请求再次访问缓存时，发现缓存缺失，再读数据库时，从数据库中读到旧值 |
| 先更新数据库再删除缓存 | 缓存删除失败，导致请求再次访问缓存时，发现缓存命中，并从缓存中读取到旧值 |



## 3. 如何解决数据不一致问题？

首先，我们可以使用：**重试机制**。

具体来说，可以把要删除的缓存值或者是要更新的数据库值暂存到消息队列中（例如使用 Kafka 消息队列）。当应用没有能够成功地删除缓存值或者是更新数据库值时，可以从消息队列中重新读取这些值，然后再次进行删除或更新。如果能够成功地删除或更新，我们就要把这些值从消息队列中去除，以免重复操作。

同样，我们按照不同的删除和更新顺序，分成两种情况来看。在这两种情况下，我们的解决方法也有所不同。



### 先删除缓存，再更新数据库

线程 A 删除缓存值后，还没有来得及更新数据库（比如说有网络延迟），线程 B 就开始读取数据了，那么这个时候，线程 B 会发现缓存缺失，就只能去数据库读取。这会带来两个问题：

* 线程 B 读取到了旧值；
* 线程 B 是在缓存缺失的情况下读取的数据库，所以，它还会把旧值写入缓存，这可能会导致其他线程从缓存中读到旧值。

具体如下：

| 时间 | 线程A       | 线程B                                                        | 问题                                                         |
| ---- | ----------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| t1   | 删除缓存X   |                                                              |                                                              |
| t2   |             | 1.读取数据X,缓存缺失，从数据库读取X，读到旧值<br/>2.把数据X写入缓存 | 1.线程A尚末将X更新到数据库，导致线程B读到旧值<br/>2.线程B把旧值写入缓存，导致其他线程可能读到旧值 |
| t3   | 更新数据库X |                                                              |                                                              |

解决方案：**延迟双删**。

**在线程 A 更新完数据库值以后，我们可以让它先 sleep 一小段时间，再进行一次缓存删除操作。**

> 感觉并不靠谱，只是降低了发送这种情况的概率，并不能完全解决问题。

大概像下面这样：

```c
redis.delKey(X)
db.update(X)
Thread.sleep(N)
redis.delKey(X)
```



### 先更新数据库值，再删除缓存值。

如果线程 A 更新了数据库中的值，但还没来得及删除缓存值，线程 B 就开始读取数据了，那么此时，线程 B 查询缓存时，发现缓存命中，就会直接从缓存中读取旧值。

> 不过，在这种情况下，如果其他线程并发读缓存的请求不多，那么，就不会有很多请求读取到旧值。而且，线程 A 一般也会很快删除缓存值，这样一来，其他线程再次读取时，就会发生缓存缺失，进而从数据库中读取最新值。所以，这种情况对业务的影响较小。

具体如下：

| 时间 | 线程A       | 线程B                                      | 问题                                         |
| ---- | ----------- | ------------------------------------------ | -------------------------------------------- |
| t1   | 更新数据库X |                                            |                                              |
| t2   |             | 读取数据X，缓存命中，从缓存读取X，读到旧值 | 线程A尚未删除缓存值，导致线程B读到缓存的旧值 |
| t3   | 删除缓存X   |                                            |                                              |





## 4. 小结

缓存和数据库的数据不一致一般是由两个原因导致的：

* **删除缓存值或更新数据库失败而导致数据不一致**，你可以使用重试机制确保删除或更新操作成功。
* **在删除缓存值、更新数据库的这两步操作中，有其他线程的并发读操作**，导致其他线程读取到旧值，应对方案是延迟双删。

对于读写缓存来说，如果我们采用同步写回策略，那么可以保证缓存和数据库中的数据一致。

只读缓存的情况比较复杂，我总结了一张表，以便于你更加清晰地了解数据不一致的问题原因、现象和应对方案。

| 操作顺序               | 是否有并发 | 潜在问题                                     | 现象                                                         | 应对方案                                     |
| ---------------------- | ---------- | -------------------------------------------- | ------------------------------------------------------------ | -------------------------------------------- |
| 先删缓存再更新数据库   | 无         | 缓存删除成功，但数据库更新失败               | 应用从数据库读到旧数据                                       | 重试更新数据库                               |
|                        | 有         | 缓存删除后，尚未更新数据库，有并发读请求     | 并发请求从数据库读到旧值，并且更新到缓存，导致后续请求都读取旧值 | 延迟双删                                     |
| 先更新数据库，再删缓存 | 无         | 数据库更新成功，但缓存删除失败               | 应用从缓存读到旧值                                           | 重试删除缓存                                 |
|                        | 有         | 数据库更新成功后，尚未删除缓存，有并发读请求 | 并发请求从缓存中读到旧值                                     | 等待缓存删除完成，期间会有不一致数据短暂存在 |



**对于只读缓存，建议优先使用先更新数据库再删除缓存的方法**，原因主要有两个：

* 先删除缓存值再更新数据库，有可能导致请求因缓存缺失而访问数据库，给数据库带来压力；
* 如果业务应用中读取数据库和写缓存的时间不好估算，那么，延迟双删中的等待时间就不好设置。