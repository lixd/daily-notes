# 并发访问

## 1. 概述

为了保证并发访问的正确性，常见的两种方法，分别是**加锁**和**原子操作**。

* 加锁将并发请求转为串行请求，自然不会有并发问题了。
  * 在单机环境中客户端本地的锁即可满足条件，但是在分布式环境中就需要分布式锁。
* 原子操作是指执行过程保持原子性的操作，而且原子操作执行时并不需要再加锁，实现了无锁操作。



Redis 可以非常简单轻量的实现分布式锁，虽然不是很完美，但是在不是非常严格的环境下依旧可以使用。

## 2. Redis 原子操作

Redis 的两种原子操作方法为了实现并发控制要求的临界区代码互斥执行，Redis 的原子操作采用了两种方法：

* 把多个操作在 Redis 中实现成一个操作，也就是单命令操作；
* 把多个操作写到一个 Lua 脚本中，以原子性方式执行单个 Lua 脚本。



比如：数据修改时可能包含多个操作，至少包括读数据、数据增减、写回数据三个操作。

> 多个客户端同时执行时就会出现问题

Redis 提供了 INCR/DECR 命令，把这三个操作转变为一个原子操作了。INCR/DECR 命令可以对数据进行增值 / 减值操作，而且它们本身就是单个命令操作，Redis 在执行它们时，本身就具有互斥性。

如果我们有多个操作要执行，但是又无法用 INCR/DECR 这种命令操作来实现，就可以把这些要执行的操作编写到一个 Lua 脚本中。

**Redis 会把整个 Lua 脚本作为一个整体执行，在执行的过程中不会被其他命令打断，从而保证了 Lua 脚本中操作的原子性。**





而 Redis 的 Lua 脚本可以包含多个操作，这些操作都会以原子性的方式执行，绕开了单命令操作的限制。不过，如果把很多操作都放在 Lua 脚本中原子执行，会导致 Redis 执行脚本的时间增加，同样也会降低 Redis 的并发性能。

* 在编写 Lua 脚本时，你要避免把不需要做并发控制的操作写入脚本中

- 要保证安全性，在 Lua 脚本中不要使用全局变量，以免污染 Lua 环境，虽然使用全局变量全报错，Lua 脚本停止执行，但还是在定义变量时添加 `local` 关键字。
- 要注意 Lua 脚本的时间复杂度，Redis 的单线程同样会阻塞在 Lua 脚本的执行中。
- 使用 Lua 脚本实现原子操作时，要注意**如果 Lua 脚本报错，之前的命令同样无法回滚**。
- 一次发出多个 Redis 请求，但请求前后无依赖时，使用 `pipeline`，比 Lua 脚本方便。

- 使用 Lua 脚本实现原子操作时，要注意如果 Lua 脚本报错，之前的命令同样无法回滚。



## 3. 分布式锁

所以，在分布式系统中，当有多个客户端需要获取锁时，我们需要分布式锁。此时，锁是保存在一个共享存储系统中的，可以被多个客户端共享访问和获取。

Redis 本身可以被多个客户端共享访问，正好就是一个共享存储系统，可以用来保存分布式锁。而且 Redis 的读写性能高，可以应对高并发的锁操作场景。



和单机上的锁类似，分布式锁同样可以用一个变量来实现。客户端加锁和释放锁的操作逻辑，也和单机上的加锁和释放锁操作逻辑一致：**加锁时同样需要判断锁变量的值，根据锁变量值来判断能否加锁成功；释放锁时需要把锁变量值设置为 0，表明客户端不再持有锁。**

但是，和线程在单机上操作锁不同的是，在分布式场景下，**锁变量需要由一个共享存储系统来维护**，只有这样，多个客户端才可以通过访问共享存储系统来访问锁变量。相应的，**加锁和释放锁的操作就变成了读取、判断和设置共享存储系统中的锁变量值**。

这样一来，我们就可以得出实现分布式锁的两个要求。

* 要求一：分布式锁的加锁和释放锁的过程，涉及多个操作。所以，在实现分布式锁时，我们需要保证这些**锁操作的原子性**；
* 要求二：共享存储系统保存了锁变量，如果共享存储系统发生故障或宕机，那么客户端也就无法进行锁操作了。在实现分布式锁时，我们需要考虑保证**共享存储系统的可靠性**，进而保证锁的可靠性。





初始版本

```c
// 加锁
SETNX lock_key 1
// 业务逻辑
DO THINGS
// 释放锁
DEL lock_key
```

这样有两个问题：

* 1）如果某个客户端获取锁后挂掉了，没有释放锁。就会导致这个锁一直被它持有，其他客户端无法获取锁
  * 可以通过给锁设置过期时间来解决该问题
* 2）锁误删除，如果客户端 A 执行了 SETNX 命令加锁后，假设客户端 B 执行了 DEL 命令释放锁，此时，客户端 A 的锁就被误释放了。如果客户端 C 正好也在申请加锁，就可以成功获得锁，进而开始操作共享数据。这样一来，客户端 A 和 C 同时在对共享数据进行操作，数据就会被修改错误，这也是业务层不能接受的。
  * 通过锁变量来区分不同客户端



优化后

```c
// 加锁, unique_value作为客户端唯一性的标识
SET lock_key unique_value NX PX 10000
```



```lua
//释放锁 比较unique_value是否相等，避免误释放
if redis.call("get",KEYS[1]) == ARGV[1] then
    return redis.call("del",KEYS[1])
else
    return 0
end
```



以上只是单机版的 Redis 分布式锁。

Redis 作者实现了基于 Redis 集群的 RedLock。

最后 Redis 实现了分布式锁并不完美，具体见该文章。

```sh
https://martin.kleppmann.com/2016/02/08/how-to-do-distributed-locking.html
```



Redis、Zookeeper etcd 这些都是常见的分布式锁方案。

