# Redis主从同步与故障切换，有哪些坑？





## 1. 主从数据不一致

主从数据不一致，就是指客户端从从库中读取到的值和主库中的最新值并不一致。

因为**主从库间的命令复制是异步进行的**。

在主从库命令传播阶段，主库收到新的写命令后，会发送给从库。

但是，主库并不会等到从库实际执行完命令后，再把结果返回给客户端，而是主库自己在本地执行完命令后，就会向客户端返回结果了。如果从库还没有执行主库同步过来的命令，主从库间的数据就不一致了。

*那在什么情况下，从库会滞后执行同步命令呢？*

* 1）主从库间的网络可能会有传输延迟，所以从库不能及时地收到主库发送的命令，从库上执行同步命令的时间就会被延后。
* 2）即使从库及时收到了主库的命令，但是，也可能会因为正在处理其它复杂度高的命令（例如集合操作命令）而阻塞，这就会造成主从数据不一致。

*应对方案*

* 1）在硬件环境配置方面，我们要尽量保证主从库间的网络连接状况良好；
* 2）利用外部程序监控主从库间的复制进度，当进度差距过大时不让客户端连接这些从库，等从库进度追上来后再解除限制即可。

使用 INFO replication 命令可以查看主库接收写命令的进度信息（master_repl_offset）和从库复制写命令的进度信息（slave_repl_offset）。



## 2. 读取过期数据

读取过期数据指，在主从集群中，有时候能在从库上读到已经过期的数据。

这是由 Redis 的过期数据删除策略引起的。

Redis 同时使用了两种策略来删除过期的数据，分别是惰性删除策略和定期删除策略。

惰性删除策略

当一个数据的过期时间到了以后，并不会立即删除数据，而是等到再有请求来读写这个数据时，对数据进行检查，如果发现数据已经过期了，再删除这个数据。

> 这个策略的好处是尽量减少删除操作对 CPU 资源的使用，对于用不到的数据，就不再浪费时间进行检查和删除了,不过存在额外的过期数据会占用较多内存。

定期删除策略

Redis 每隔一段时间（默认 100ms），就会随机选出一定数量的数据，检查它们是否过期，并把其中过期的数据删除，这样就可以及时释放一些内存。

>  为了避免过多删除操作对性能产生影响，每次随机检查数据的数量并不多。如果过期数据很多，可能还是会留存在 Redis 中。



惰性删除策略中，数据只有被再次访问时，才会被实际删除。如果客户端从主库上读取留存的过期数据，主库会触发删除操作，此时，客户端并不会读到过期数据。但是，**从库本身不会执行删除操作，如果客户端在从库中访问留存的过期数据，从库并不会触发数据删除**。至于是否会将数据返回给客户端则和 Redis 版本有关：

* Redis 3.2 之前的版本，那么，从库在服务读请求时，并不会判断数据是否过期，而是会返回过期数据。

* 在 3.2 版本后，Redis 做了改进，如果读取的数据已经过期了，从库虽然不会删除，但是会返回空值，这就避免了客户端读到过期数据。

**所以在应用主从集群时，尽量使用 Redis 3.2 及以上版本。**



另外Redis 用于设置过期时间的命令不同也会导致访问到过期数据。

* EXPIRE 和 PEXPIRE：它们给数据设置的是**从命令执行时开始计算的存活时间**；
* EXPIREAT 和 PEXPIREAT：它们会直接**把数据的过期时间设置为具体的一个时间点**。

如果主库接收到了一条 EXPIRE 命令，主库执行完成后会将该命令同步给从库，然后从库再执行该命令。如果这过程中有延迟，那么从库上设置的过期时间相比主库就延后了。

假设当前时间是 2020 年 10 月 24 日上午 9 点，主从库正在同步，主库收到了一条命令：EXPIRE testkey 60，这就表示，testkey 的过期时间就是 24 日上午 9 点 1 分，主库直接执行了这条命令。

但是，过了 2 分钟该命令才同步到从库。等从库开始执行这条命令时，时间已经是 9 点 2 分了。而 EXPIRE 命令是把 testkey 的过期时间设置为当前时间的 60s 后，也就是 9 点 3 分。如果客户端在 9 点 2 分 30 秒时在从库上读取 testkey，仍然可以读到 testkey 的值。但是，testkey 实际上已经过期了。

为了避免这种情况，我给你的建议是，**在业务应用中使用 EXPIREAT/PEXPIREAT 命令，把数据的过期时间设置为具体的时间点，避免读到过期数据**。





## 3. 不合理配置项导致的服务挂掉

主从故障切换时，也会因为配置不合理而踩坑。

这里涉及到的配置项有两个，分别是` protected-mode` 和 `cluster-node-timeout`。

**1）protected-mode 配置项**

这个配置项的作用是限定哨兵实例能否被其他服务器访问。当这个配置项设置为 yes 时，哨兵实例只能在部署的服务器本地进行访问。当设置为 no 时，其他服务器也可以访问这个哨兵实例。

> 如果 protected-mode 被设置为 yes，而其余哨兵实例部署在其它服务器，那么，这些哨兵实例间就无法通信。当主库故障时，哨兵无法判断主库下线，也无法进行主从切换，最终 Redis 服务不可用。



**所以，我们在应用主从集群时，要注意将 protected-mode 配置项设置为 no**。这样一来，不同实例上的哨兵实例间能够通信进行主从切换。





**2）cluster-node-timeout 配置项**

**这个配置项设置了 Redis Cluster 中实例响应心跳消息的超时时间。**

当我们在 Redis Cluster 集群中为每个实例配置了“一主一从”模式时，如果主实例发生故障，从实例会切换为主实例，受网络延迟和切换操作执行的影响，切换时间可能较长，就会导致实例的心跳超时（超出 cluster-node-timeout）。实例超时后，就会被 Redis Cluster 判断为异常。而 Redis Cluster 正常运行的条件就是，有半数以上的实例都能正常运行。

所以，如果执行主从切换的实例超过半数，而主从切换时间又过长的话，就可能有半数以上的实例心跳超时，从而可能导致整个集群挂掉。**所以，最好将 cluster-node-timeout 调大些（例如 10 到 20 秒）。**



## 4. 小结

| 坑                     | 原因                                                     | 解决方案                                                     |
| ---------------------- | -------------------------------------------------------- | ------------------------------------------------------------ |
| 主从数据不一致         | 主从数据异步复制，网络问题或者从库被阻塞导致同步进度滞后 | 保证主从良好的网络环境<br/>使用外部程序监控主从同步进度，禁止客户端从进度落后的从库读取数据 |
| 读到过期数据           | 过期数据删除策略                                         | 使用 Redis 3.2 及以上版本<br/>使用EXPIREAT 和 PEXPIREAT设置过期时间 |
| 不合理配置导致服务挂掉 | protected-mode 和 cluster-node-timeout 配置不合理        | 设置 protected-mode 为 no <br/>调大 cluster-node-timeout     |

