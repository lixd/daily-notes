## 1. 普通查询

| 关键词              | keyword类型        | text类型                                                     | 是否分词 | 备注 |
| ------------------- | ------------------ | ------------------------------------------------------------ | -------- | ---- |
| term                | 完全匹配           | 查询条件**`必须都是`**text分词中的，且不能多余，多个分词时**`必须连续`**，顺序不能颠倒。 | 否       |      |
| match               | 自动转为 term 查询 | match分词结果和text的分词结果**`至少一个`**相同即可，**`不考虑顺序`** | 是       |      |
| match_phrase        | 完全匹配           | match_phrase的分词结果必须在text字段分词中**`都包含`**，而且顺序必须相同，而且必须**`都是连续`**的。 | 是       |      |
| match_phrase_prefix | 完全匹配           | 该`match_phrase_prefix`是一样的`match_phrase`，不同的是它允许对文本的最后一项前缀匹配 |          |      |
| query_string        | 完全匹配           | 只能查询 text类型。query_string中的分词结果**`至少有一个`**在text字段的分词结果中，**`不考虑顺序`** | 是       |      |

所有对`keyword`的查询，都是不会进行分词的。

match 和 query_string 很像，只是 query_string 只能查询 string

match_phrase 就像是分词版的 term 查询。



## 2. 布尔查询

**must**子句：文档必须匹配must查询条件；

**should**子句：文档应该匹配should子句查询的一个或多个；

**must_not**子句：文档不能匹配该查询条件；

**filter**子句：过滤器，文档必须匹配该过滤条件，跟must子句的唯一区别是，filter不影响查询的score；

布尔查询嵌套结构会影响相似度算分。

同一层级的权重相同。

## 3. query & filter

query关注点：此文档与此查询子句的匹配程度如何？
filter关注点：此文档和查询子句匹配吗？

query 上下文的条件是用来给文档打分的，匹配越好 _score 越高；filter 的条件只产生两种结果：符合与不符合，后者被过滤掉。 这个 总结可以

