# GMP 模型



## GM 模型

Go1.2之前没有P，只有GM模型。

只有一个全局队列，所有M都去全局队列拿G来执行。

问题：

* 只有一个全局队列，需要加锁，性能低
* 局部性差，G1在M1上运行，然后G1又开了一个G2，这时候会把G2放到全局队列，然后可能就被其他M拿去执行了。按照局部性原理，G2肯定是在M1上执行最好





## GMP模型

设计策略：

* 复用线程：避免频繁创建、销毁线程，而是进行复用
  * work stealing 机制：当P的本地队列没有G可执行时，会先去全局队列拿，如果全局队列都没有就会尝试从其他P的队列里窃取一些G过来运行，而不是直接把当前线程销毁了
  * hand off 机制：当本线程因为G进行系统调用阻塞时，线程释放绑定的P，把P转移给其他空闲的线程执行。
* 利用并行：GOMAXPROCS设置P的数据，最多有GOMAXPROCS个P和M绑定运行
* 抢占：每个G最多占用CPU 10ms，防止其他G被饿死。
* 全局G队列：