# Go抢占式调度和基于信号的调度

### 抢占式调度

Gc将正在运行的goroutine的stackgurd0设置为stackpreempt这个特殊标识，表示gc正等着你让出呢。同时还会给gc设置设置gcwaiting标识，表示gc正在等待goroutine退出。
同时编译器会在有明显栈增长的函数头部插入栈增长检测代码，在需要的时候进行栈扩容，防止栈溢出。
而有stack preempt标识的时候就不会执行栈增长检测，而是执行这个调度schedule。
而schedule中又会检测如果有gcwaiting标识，即gc正在等待，则会让出当前p，以保证gc顺利进行。
那么问题来了，一个空的for循环，没有调用函数自然不会出发栈增长检测，也就不会检测到stackpreempt标识去执行schedule，更不会在schedule中检测到gcwaiting标识让出当前p了，于是gc一直等，for循环呢也一直不会让出，最后结果就是程序就被阻塞了。
这就是go1.14之前的抢占式调度的问题。

## 基于信号的调度

1.14之后则通过信号方式修改了调度逻辑。
需要调度的时候直接发送一个信号，通过系统调用将信号发送给指定线程，工作线程收到信号后会调用runtime.signalhandler来处理信号，处理逻辑就是通过pushCall直接给这个goroutine的上下文中注入一个异步抢占函数调用，这是一个汇编函数，这个func会先保存现场，把各个寄存器的值保存在栈上，然后调度schedule方法，后续schedule方法检测到gcwaiting标识就会让出当前p，这里和之前一致。
这样就算是一个空的for循环，只要也可以完成调度。