# 方法

## 1. 概述

在某些情况下，我们要需要声明(定义)方法。比如Person结构体:除了有一些字段外(年龄、姓名..)。Person结构体还有一些行为比如:可以说话、跑步...学习，还可以做算术题。这时就要用方法才能完成。
Golang中的方法是**作用在指定的数据类型上的**(即：和指定的数据类型绑定}，因此**自定义类型，都可以有方法**，而不仅仅是struct。

```go
//结构体A
type A struct{

}
//方法test 只有A类型可以调用
func (a A)test(){
    
}
var a A
a.test()

```

### 1.1 例子

```go
package main

import "fmt"

func main() {
	p1 := Person{"illusory", 11}
	p1.run() //调用方法
}

type Person struct {
	Name string
	Age  int
}

//给Personm绑定一个方法
func (person Person) run() {
	fmt.Printf("%s running....", person.Name)
}

```

说明：

* 1.run 方法和 Personm 结构体绑定
* 2.run 方法只能通过 Person 类型的变量来调用，不能使用其他类型或者直接调用
* 3.func (`person` Person) run() {} 这里的 person 表示哪个 Person 变量调用，这个 person 就是它的副本，和函数传参非常相似
* 4.person 这个名字可以随意指定 不是固定的

## 2. 方法调用和传参原理

方法的调用和传参机制与函数基本一样，不一样的地方是方法调用时，**会将调用方法的变量，当做实参也传递给方法**。

为了提高效率，通常和方法绑定的是结构体的指针类型

```go
package main

import "fmt"

func main() {
	p1 := Personm{"illusory", 11}
    (&p1).run() //正常调用
	p1.run() //编译器底层优化 直接这样调用也是可以的 会自动转化为上面的调用方式
}

type Personm struct {
	Name string
	Age  int
}

//给Personm绑定一个方法
func (person *Personm) run() {
	fmt.Printf("%s running....", person.Name)
}

```

## 3. 方法注意事项与细节

* 1.结构体类型是值类型，在方法调用中，遵守值类型的传递机制，是值拷贝传递方式
* 2.如程序员希望在方法中，修改结构体变量的值，可以通过结构体指针的方式来处理
* 3.Golang中的方法**作用在指定的数据类型上**的(即：**和指定的数据类型绑定**)，因此**自定义类型，都可以有方法**，而不仅仅是struct,比如int,float32等都可中以有方法
* 4.方法的访问范围控制的规则，和函数一样。方法名首字母小写，只能在本包访问，方法首字母大写，可以在本包和其它包访问。
* 5.如果一个变量实现了String()这个方法，那么fmt.Println默认会调用这个变量的String()进行输出,类似Java中的toString()

## 4. 方法与函数区别

Go 语言中方法和函数在形式上很像，**它是作用在接收器（receiver）上的一个函数**，接收器是某种类型的变量。因此方法是一种特殊类型的函数，方法只是比函数多了一个接收器（receiver），当然在接口中定义的函数我们也称为方法（因为最终还是要通过绑定到类型来实现）。

正是因为有了接收器，方法才可以作用于接收器的类型（变量）上，类似于面向对象中类的方法可以作用于类属性上。

### 4.1 接收器(receiver)

- 接收器类型除了不能是指针类型或接口类型外，可以是其他任何类型，不仅仅是结构体类型，也可以是函数类型，还可以是 int、bool、string 等等为基础的自定义类型。
- 接收器不能是一个接口类型，因为接口是一个抽象定义，但是方法却是具体实现；
- 接收器不能是一个指针类型，但是它可以是任何其他允许类型的指针,接收器不能是指针类型，但可以是类型的指针，有点绕口。



* 如果有类型T，方法的接收器为(t T)时我们称为值接收器，该方法称为值方法；

* 方法的接收器为(t *T)时我们称为指针接收器，该方法称为指针方法。



类型 T（或 *T）上的所有方法的集合叫做类型 T（或 *T）的方法集。

> 关于接收器的命名
>
> 社区约定的接收器命名是类型的一个或两个字母的缩写(像 c 或者 cl 对于 Client)。**不要使用泛指的名字像是 me，this 或者 self，也不要使用过度描述的名字，简短即可**。

**实体类型以`值接收者`实现接口的时候，不管是实体类型的`值`，还是实体类型值的`指针`，都实现了该接口**。

**实体类型以`指针接收者`实现接口的时候，只有指向这个类型的`指针`才被认为实现了该接口**

### 4.2 选择器（selector）

这里我们了解下Go语言的选择器（selector），如：

```
x.f
```

如果x不是包名，则表示是x（或* x）的f（字段或方法）。标识符f（字段或方法）称为选择器(selector)，选择器不能是空白标识符。选择器表达式的类型是f的类型。

选择器f可以表示类型T的字段或方法，或者指嵌入字段T的字段或方法f。遍历到f的嵌入字段的层数被称为其在T中的深度。在T中声明的字段或方法f的深度为零。在T中的嵌入字段A中声明的字段或方法f的深度是A中的f的深度加1。

在Go语言中，我们认为方法的显式接收器(explicit receiver)x是方法x.m()的等效函数X.m()的第一个参数，所以x.m()和X.m(x)是等价的

Go语言中类型加上它的方法集等价于面向对象中的类。但在 Go 语言中，类型的代码和绑定在它上面的方法集的代码可以不放置在同一个文件中，它们可以保存在同一个包下的其他源文件中。

下面是在非结构体类型上定义方法的例子：

```
type MyInt int

func (m MyInt) print() { // 值方法
	fmt.Println("MyInt:", m)
}
```

注意：**类型和作用在它上面定义的方法必须在同一个包里定义**，所以基础类型int、float 等上不能直接定义。    

类型在其他的，或是非本地的包里定义，在它上面定义方法都会发生错误。



虽然我们不能直接为非同一包下的类型直接定义方法，但我们可以以这个类型（比如：int 或 float）为基础来自定义新类型，然后再为新类型定义方法。

### 4.3 接口变量上的指针方法与值方法

无论是T类型变量还是*T类型变量，都可调用值方法或指针方法。但如果是接口变量呢，那么这两个方法都可以调用吗？

Go语言的一种规则，具体如下：

- **规则一：如果使用指针方法来实现一个接口，那么只有指向那个类型的指针才能够实现对应的接口。**
- **规则二：如果使用值方法来实现一个接口，那么那个类型的值和指针都能够实现对应的接口。**

```go
package main

type T struct {
	Name string
}
type Intf interface {
	M1()
	M2()
}

func (t T) M1() {
	t.Name = "name1"
}

func (t *T) M2() {
	t.Name = "name2"
}
func main() {

	var t1 T = T{"t1"}
	t1.M1()
	t1.M2()

	var t2 Intf = &t1
	t2.M1()
	t2.M2()
}
```

其中`M1()`是值方法，可以用值或者指针调用，`M2()`为指针方法只能使用指针类型调用。

### 4.4 如何选择接收器

按照上面的两条规则，那究竟怎么选择是指针接收器还是值接收器呢？

#### 何时使用值类型

（1）如果接收器是一个 map，func 或者 chan，使用值类型（因为它们本身就是引用类型）。 

（2）如果接收器是一个 slice，并且方法不执行 reslice 操作，也不重新分配内存给 slice，使用值类型。 

（3）如果接收器是一个小的数组或者原生的值类型结构体类型(比如 time.Time 类型)，而且没有可修改的字段和指针，又或者接收器是一个简单地基本类型像是 int 和 string，使用值类型就好了。

值类型的接收器可以减少一定数量的内存垃圾生成，值类型接收器一般会在栈上分配到内存（但也不一定），在没搞明白代码想干什么之前，别为这个原因而选择值类型接收器。

#### 何时使用指针类型

> 官方文档：https://github.com/golang/go/wiki/CodeReviewComments#receiver-type

（1）如果方法需要**修改接收器里的数据**，则接收器**必须是指针类型**。 

（2）如果接收器是一个包含了 sync.Mutex 或者类似同步字段的结构体，接收器必须是指针，这样可以避免拷贝。 

（3）如果接收器是一个**大的结构体或者数组**，那么**指针类型接收器更有效率**。 

（4）如果接收器是一个结构体，数组或者 slice，它们中任意一个元素是指针类型而且可能被修改，建议使用指针类型接收器，这样会增加程序的可读性。

**最后如果实在还是不知道该使用哪种接收器，那么记住使用指针接收器是最靠谱的**。

### 4.5 具体区别

* 1.调用方式不一样

  ​	函数调用：函数名(实参列表)

  ​	方法调用：变量.方法名(实参列表)

* 2. 对于普通函数，接收者为值类型时，不能将指针类型的数据直接传递，反之亦然
* 3.对于方法(如struct 的方法)，接收者为值类型时，可以直接用指针类型的变量调用方法，反之亦然

**编译器底层会自动转化，最终还是以绑定类型为准** 

```go
package main

import "fmt"

func main() {
	p1 := Personm{"illusory", 11}
    (&p1).run() //正常调用
	p1.run() //编译器底层优化 直接这样调用也是可以的 会自动转化为上面的调用方式 看起来是传递值但是最后还是传递的指针 内部对Name的修改依旧会影响到外部的值
}

type Personm struct {
	Name string
	Age  int
}

//给Personm绑定一个方法 传递的是指针
func (person *Personm) run() {
    person.Name="tom" //修改Name
	fmt.Printf("%s running....", person.Name)
}

```

**总结：**不管调用形式如何，真正**决定是值拷贝还是地址拷贝**的是**该方法是和哪个类型绑定的**

如果是和值类型绑定：(person Person) 则是值拷贝

如果是和引用类型绑定：(person *Person) 则是地址拷贝



## 匿名类型的方法提升

当一个匿名类型被嵌入在结构体中时，匿名类型的可见方法也同样被内嵌，这在效果上等同于外层类型继承了这些方法：将父类型放在子类型中来实现亚型。这个机制提供了一种简单的方式来模拟经典面向对象语言中的子类和继承相关的效果。

**当我们嵌入一个匿名类型，这个类型的方法就变成了外部类型的方法，但是当它的方法被调用时，方法的`接收器`是`内部类型(嵌入的匿名类型)`，而非外部类型**。

```go
type People struct {
	Age    int
	gender string
	Name   string
}

type OtherPeople struct {
	People
}

func (p People) PeInfo() {
	fmt.Println("People ", p.Name, ": ", p.Age, "岁, 性别:", p.gender)
}
```

因此嵌入类型的名字充当着字段名，同时嵌入类型作为内部类型存在，我们可以使用下面的调用方法：

```go
OtherPeople.People.PeInfo()
```

这儿我们可以通过类型名称来访问内部类型的字段和方法。然而，这些字段和方法也同样被提升到了外部类型，我们可以直接访问：

```go
OtherPeople.PeInfo()
```

前面我们看到了嵌入类型的方法提升，在 Go 语言中匿名嵌入类型方法集提升的规则：

给定一个结构体类型 S 和一个命名为 T 的类型，方法提升像下面规定的这样被包含在结构体方法集中：

**简单地说是两条规则：**

**规则一：如果S包含嵌入字段T，则S和 *S的方法集都包括具有接收方T的提升方法。 *S的方法集还包括具有接收方 *T的提升方法。**

**规则二：如果S包含嵌入字段*T，则S和 *S的方法集都包括具有接收器T或 *T的提升方法。**

当嵌入一个类型，嵌入类型的接收器为指针的方法将不能被外部类型的值访问。这跟接口规则一致。

注意：以上规则在调用指针方法 t.M() 时会被自动转换为 (&t).M() ，由于这个语法糖，导致我们很容易误解上面的规则不起作用，而实际上规则是有效的，在实际应用中我们可以留意这个问题。

