# HTTP/2 流与多路复用

**在一个 HTTP/2 的连接中, 流是服务器与客户端之间用于帧交换的一个独立双向序列**。流有几个重要的特点:

- 一个 HTTP/2 连接可以包含多个并发的流, 各个端点从多个流中交换 frame
- 流可以被客户端或服务器单方面建立, 使用或共享
- 流也可以被任意一方关闭
- frames 在一个流上的发送顺序很重要. 接收方将按照他们的接收顺序处理这些frame. 特别是`HEADERS`和`DATA` frame的顺序, 在协议的语义上显得尤为重要.
- 流用一个整数(流标识符)标记. 端点初始化流的时候就为其分配了标识符.



每个桢都有一个流标示，标记自己属于哪个流。通过将相同流标识的桢组装，桢之间时有严格顺序的，即形成了“流”。

> 因此流也是一个虚拟概念，只是每个帧上带了标记表示自己属于哪个流而已。



## Stream的状态

### Stream的生命周期

下图展示了流的生存周期:

```shell
                         +--------+
                 send PP |        | recv PP
                ,--------|  idle  |--------.
               /         |        |         \
              v          +--------+          v
       +----------+          |           +----------+
       |          |          | send H /  |          |
,------| reserved |          | recv H    | reserved |------.
|      | (local)  |          |           | (remote) |      |
|      +----------+          v           +----------+      |
|          |             +--------+             |          |
|          |     recv ES |        | send ES     |          |
|   send H |     ,-------|  open  |-------.     | recv H   |
|          |    /        |        |        \    |          |
|          v   v         +--------+         v   v          |
|      +----------+          |           +----------+      |
|      |   half   |          |           |   half   |      |
|      |  closed  |          | send R /  |  closed  |      |
|      | (remote) |          | recv R    | (local)  |      |
|      +----------+          |           +----------+      |
|           |                |                 |           |
|           | send ES /      |       recv ES / |           |
|           | send R /       v        send R / |           |
|           | recv R     +--------+   recv R   |           |
| send R /  `----------->|        |<-----------'  send R / |
| recv R                 | closed |               recv R   |
`----------------------->|        |<----------------------'
                         +--------+

   send:   发送这个frame的终端
   recv:   接受这个frame的终端

   H:  HEADERS帧 (隐含CONTINUATION帧)
   PP: PUSH_PROMISE帧 (隐含CONTINUATION帧)
   ES: END_STREAM标记
   R:  RST_STREAM帧
```



### Stream标识符

**每个流都用31位无符号整型标识**。 为了便于区分，客户端初始化流时必须使用奇数做标识, 而服务器初始化的流则要使用偶数做标识。 

> 注: 流标识符0x0用于连接控制消息, 不能用于建立一个新的流.

新建立的流标识符必须在大于所有由该端系统已打开或保留的流。

> 即 StreamID 只能单调递增，不能复用

首次使用一个新的流标识符会隐式关闭所有该端系统初始化的处于idle状态且标识符更小的流。 

> 就是说, 如果一个客户端通过7号流发送了一个HEADERS帧, 并且它尚未使用5号流发送过帧, 那么当7号流上的第一个帧已发送或接收时, 5号流就会变为closed状态。

如果一个客户端无法建立新的流了, 那么他可以选择建立新连接来创建新的流。同样, 当服务器不能建立新的流时, 可以发送一个 GOAWAY 帧以便客户端强制打开一个到服务器的新连接来创建新的流。



### Stream的并发性

一个对等端可以通过SETTINGS帧的`SETTINGS_MAX_CONCURRENT_STREAMS`字段限制活跃状态的流的并发数, 流的最大并发量设置是特定于每个端系统而言的, 并且只作用于收到设置的对等端. 也就是说, 客户端指定服务器可用来初始化流的最大并发数, 反之亦然.





## 流控

**流控手段确保同一连接上的流互相之间不会产生严重的妨碍**。

流的多路复用会让 TCP 连接的使用产生竞争, 这会导致流的阻塞。流控既可用于某个单独的流, 也可用于整个连接。

> HTTP/2通过使用WINDOW_UPDATE帧提供了流控功能.



流控具有以下特点:

* 1）**流控针对于连接**，而非整个端到端链路。即：所有类型的流控都作用于两个单跳的端系统之间, .
* 2）**流控基于 WINDOW_UPDATE 帧实现**，接收者告知他们准备在一个流上以及整个连接上分别接收多少字节。
  * 这属于基于信用的模型，类似于君子约定，如果实现方不按照这个处理也没版本
* 3）**流控具有方向性, 且完全由接收者控制**。 接收方可以选择给每个流和整个连接设置期望的任意窗口大小
* 4）对于所有的流和连接, 流控窗口的**初始大小是65535字节**(2^16)
* 5）**只有DATA帧是流控的作用对象**， 其他所有类型的帧均不占用流控窗口空间。
  * 这样可以保证重要的控制帧不会因流控被阻塞
* 6）流控不能关闭
* 7）RFC 文档只定义了 WINDOW_UPDATE 帧的格式和语义，没有规定具体实现。



## Stream的优先级

客户端可以给一个新的流分配一个优先级, 做法是在用来打开流的 HEADERS 帧中包含优先次序信息，或者单独发一个 PRIORITY 帧来改变一个流的优先级。

> 默认权重为16

优先级的目的是在并发流管理的时候, 允许端系统选择它所期望的对等端分配资源方式。最重要的是, 当发送受到限制的情况下, 可以通过优先级选择使用哪个流来传输帧。



### Stream的依赖关系

每个流可以显式指定依赖其他的流. 如果流被其他流所依赖, 这就表明这个流在资源的分配上优先于它的从属流.

向下面这样，流B和流C依赖流A。

```
   A              
  / \     
 B   C           
```

依赖于相同上级的流应该依据其权重比例分配资源。

因此, 上图中如果流B权重为4,流C权重为12,那么B会分得1/4的资源, C分得3/4的资源。

